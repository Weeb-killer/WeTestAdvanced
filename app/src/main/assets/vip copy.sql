drop table if exists timutimu;
drop table if exists stack;
create table timutimu(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255),
                            'Search_Algorithm' int(1),
                            'sorting_algorithm' int(1),
                            'Link_List' int(1),
                            'queue' int(1),
                            'stack' int(1),
                            'array' int(1),
                            'tree' int(1),
                            'graph' int(1));

create table stack(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table quene(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table linear(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));        

create table String(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));        
                            
create table Multarray(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));         

create table Btree(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));       

create table Htree(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));  

create table Ungraphs(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));  

create table Dgraphs(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table GraphT(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));
                        
create table PK(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table seqSearch(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table BST(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table OAISort(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table Heapsort(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));
                        
create table Quicksort(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));

create table Mergesort(id integer primary key AUTOINCREMENT,
                            content VARCHAR(255),option_A VARCHAR(255),option_B VARCHAR(255),
                            option_C VARCHAR(255),option_D VARCHAR(255),correct_ot integer,
                            explanation VARCHAR(255));



insert into stack(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('链栈与顺序栈相比，比较明显的优点是()',
            'A.插入操作更加方便',
            'B.删除操作更加方便',
            'C.入栈时不需要扩容',
            'D.我不到啊',3,
            '解:入栈时不需要扩容_每次入栈相当于链表中头插一个节点，没有扩容一说'),



            ('给定一个包括括号的字符串 s ，判断字符串是否有效。那么‘***’处应该填入的代码是？\n'+
            'def isValid(self, s: str) -> bool:\n'+
            '       dic = {'{': '}',  '[': ']', '(': ')', '?': '?'}\n'+
            '       stack = ['?']\n'+
            '       for c in s:\n'+
            '           ***\n'+
            '           elif dic[stack.pop()] != c: return False \n'+
            '       return len(stack) == 1',
            'A.if c in dic: stack.append(c)',
            'B.if c in dic: stack.pop(c)',
            'C.if c in dic: stack.push(c)',
            'D.我不到啊',1,
            'A.栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空'),



            ('仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作。当定义push函数的时候‘***’处的语句是？\n'+
            'def push(self, x: int) -> None:\n'+
            '      self.queue2.append(x)\n'+
            '          ***\n'+
            '          self.queue2.append(self.queue1.popleft())\n'+
            '      self.queue1, self.queue2 = self.queue2, self.queue1',
            'A.if self.queue1:',
            'B.for self.queue1:',
            'C.while self.queue1:',
            'D.我不到啊',3,
            '拓展：collections.deque()是Python标准库collections模块中的一个类，用于实现双端队列（deque）数据结构。deque是一种可以从两端进行高效插入和删除操作的数据结构，类似于队列和栈的结合'),



            (' 一个栈的入栈序列为ABCDE，则不可能的出栈序列为（ ）',
            'A .ABCDE',
            'B .EDCBA',
            'C .DCEBA',
            'D .ECDBA',4,
            'D.此题型虽说不是编程题，但是在非编程题中还是挺常见的！可以直接看着分析，也可以直接画图，画图是最稳妥的做法。切记压栈出栈只能是栈顶。'),



            ('借助于栈输入A、B、C、D四个元素（进栈和出栈可以穿插进行），则不可能出现的输出是 ()',
            'A .DCBA',
            'B .ABCD',
            'C .CBAD',
            'D .CABD',4,
            'D.此题型虽说不是编程题，但是在非编程题中还是挺常见的！可以直接看着分析，也可以直接画图，画图是最稳妥的做法。切记压栈出栈只能是栈顶。'),



            ('栈和队列都是()',
            'A、顺序存储的线性结构',
            'B、链式存储的非线性结构',
            'C、限制存取点的线性结构',
            'D、限制存取点的非线性结构',3,
            'C.栈是一种只允许在一端进行插入或删除操作的线性表，它是一种特殊的线性表，它与队列具有相同的逻辑结构，都属于线性结构，区别在于对其中元素的处理不同，栈遵循的原则是先进后出（FILO），即后进的元素先被取出来，它是被限制存取点的线性结构。'),


            ('栈和队列的共同点是（）',
            'A、都是先进先出',
            'B、都是先进后出',
            'C、只允许在端点处插入和删除元素',
            'D、没有共同点',3,
            'C.栈和队列的共同点是都只允许在一端进行插入或删除操作的特殊线性表，主要区别在于插入、删除操作的限定不一样'),



            ('设栈S和队列Q的初始状态为空，元素a，b，c，d，e，f依次通过栈S，一个元素出栈后即进队列Q，若6个元素出队的序列是a，c，f，e，d，b，则栈S的容量至少应该是（）。',
            'A.3',
            'B.4',
            'C.5',
            'D.6',2,
            'B.栈是先进后出，队列是先进先出。若容量为3，若要满足条件，首先元素a通过栈S后，然后进入队列Q，得到出队为{a}；b、c通过栈S后，c首先出栈通过队列，得到出队为{a、c}；此时若要第三个出队元素为f，则栈中由下至上应该为{b、d、e、f}，所以栈S的容量至少应该是4。'),


            ('采用共享栈的好处是（）。',
            'A、减少存取时间，降低发生上溢的可能',
            'B、节省存储空间，降低发生上溢的可能',
            'C、减少存取时间，降低发生下溢的可能',
            'D、节省存储空间，降低发生下溢的可能',2,
            'B.使用共享栈可以更加有效地利用存储空间，降低发生上溢的可能，通过让两个顺序栈共享一个一维数组空间，将这两个顺序栈的栈底分别设置在数组空间的两端，其中两个栈的栈顶指针都指向栈顶元素'),
            


            ('假设循环队列的最大容量为m，队头指针是front，队尾指针是rear，则队列为满的条件是()',
            'A、(rear+1)%m == front',
            'A、rear == front',
            'C.rear+1 == front',
            'D.(rear-1)%m == front',1,
            'A.设MaxSize为循环队列的最大容量，(Q.rear+1)%MaxSize == Q.front即队尾指针进1与MaxSize取余的值等于头指针时，此时队列已满');



            ('下列关于栈叙述正确的是（()',
            'A.算法就是程序',
            'B.设计算法时只需要考虑数据结构的设计',
            'C.设计算法时只需要考虑结果的可靠性',
            'D.以上三种说法都不对',4,
            'A：程序是数据结构+算法，错。B,C：设计一个算法时，考虑的因素很多。首先要满足算法的五个基本特性：确定性，可行性，有穷性，输入，输出。其次，再从可读性，健壮性，低耦合高效率，低存储等方面进行优化。'),



            ('若有一个栈的输入序列是1,2,3，…，n，输出序列的第一个元素是n，则第i个输出元素是()',
            'A.n-i',
            'B.n-i-1',
            'C.n-i+1',
            'D.我不到啊',3,
            'C.'),


            ('一个栈的输入序列为1 2 3 4 5，则下列序列中不可能是栈的输出序列的是()',
            'A.1 5 4 3 2',
            'B.2 3 1 4 5',
            'C.2 3 4 1 5',
            'D.5 4 1 3 2',4,
            'D.'),


            ('支持子程序调用的数据结构是()',
            'A.栈',
            'B.树',
            'C.队列',
            'D.二叉树',1,
            'A.'),



            ('现有初始状态均为空的栈X和队列Y，元素a、b、c、d、e、f、g依次进入栈X，每个元素出栈后即进入队列Y，如果出队列的顺序为b、c、f、e、g、d、a，则要求栈X最小容量为()',
            'A.6',
            'B.5',
            'C.4',
            'D.3',3,
            'C.'),



            ('在栈中，（）保持不变。()',
            'A.栈的顶',
            'B.栈的底',
            'C.栈指针',
            'D.栈中的数据',2,
            'B.'),



            ('判定一个顺序栈 st （最多元素为 MaxSize ）为空的条件是 ()',
            'A.st->top != -1',
            'B.st->top == -1',
            'C.st->top != MaxSize',
            'D.st->top == MaxSize',2,
            'B.'),



            ('若栈采用链式存储结构,则下列说法中正确的是()',
            'A.需要判断栈满但不需要判断栈空',
            'B.不需要判断栈满也不需要判断栈空',
            'C.需要判断栈满且需要判断栈空',
            'D.不需要判断栈满但需要判断栈空',4,
            'D.'),



            ('调用函数时，入参及返回地址使用了（）',
            'A.队列',
            'B.多维数组',
            'C.顺序表',
            'D.栈',4,
            'D.'),


            ('下面关于栈和队列的说法中错误的是()',
            'A.队列和栈通常都使用链表实现',
            'B.队列和栈都可以从两端插入、删除数据',
            'C.队列和栈都不支持随机访问和随机插入',
            'D.队列是"先入先出"，栈是"先入后出"',1,
            'A.队列和栈通常都使用链表实现 栈是尾部插入和删除，一般使用顺序表实现，队列是头部删除尾部插入，一般使用链表实现');



insert into quene(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('假设循环队列的最大容量为m，队头指针是front，队尾指针是rear，则队列为满的条件是（）',
            'A.(rear+1)%m == front',
            'B.rear == front',
            'C.rear+1 == front',
            'D.(rear-1)%m == front',1,
            'A.设MaxSize为循环队列的最大容量，(Q.rear+1)%MaxSize == Q.front即队尾指针进1与MaxSize取余的值等于头指针时，此时队列已满'),


            ('用循环单链表来表示队列，设队列的长度为n，若只设尾指针，则出队和入队的时间复杂度分别为（）',
            'A.O(1),O(1)',
            'B.O(1),O(n)',
            'C.O(n),O(1)',
            'D.O(n),O(n)',1,
            'A.循环单链表表示队列相当于一个环，由于只设尾指针，出队时直接出队，出队的时间复杂度为O(1)；因为队头队尾相连，尾指针的下一个结点即是队头，则入队的时间复杂度也为O(1)'),

            ('已知存储循环队列的数组长度为21，若当前队列的头指针和尾指针的值分别为9和3，则该队列的当前长度为（）。',
            'A.6',
            'B.12',
            'C.15',
            'D.18',3,
            'C.通过队尾指针减队头指针加上MaxSize的值与MaxSize取余，可得到数据元素个数，即(Q.rear-Q.front+MaxSize)%MaxSize'),


            ('循环队列存储在数组A[0,…,m]中，用front和rear分别表示队头和队尾，则入队时的操作为（）',
            'A.rear=rear+1',
            'B.rear=(rear+1) mod (m-1)',
            'C.rear=(rear+1) mod m',
            'D.rear=(rear+1) mod (m+1)',4,
            'D.入队操作针对Q.rear，入队的代码通过取余运算实现，队尾指针加1，即Q.rear=(Q.rear+1)%MaxSize，不管前面(Q.rear+1)为多少，它与MaxSize（例如，MaxSize=5）取余的结果只可能是0、1、2、3、4，也就是队尾指针Q.rear的每次移动加1。'),


            ('循环队列存储在数组A[0,…,m]中，用front和rear分别表示队头和队尾，则出队时的操作为()',
            'A.front=front+1',
            'B.front=(front+1) mod (m-1)',
            'C.front=(front+1) mod m',
            'D.front=(front+1) mod (m+1)',4,
            'D.出队的代码依然是通过取余运算实现，队头指针加1，即Q.front=(Q.front+1)%MaxSize，我们知道不管前面(Q.front+1)为多少，它与MaxSize（例如，MaxSize=5）取余的结果只可能是0、1、2、3、4，也就是队头指针Q.front的每次移动加1。'),

            ('若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别是0和3。当从队列中加入一个元素，删除两个元素，再加入三个元素后，再删除一个元素，此时rear和front的值分别是（）。',
            'A.1和3',
            'B.0和4',
            'C.4和0',
            'D.3和1',3,
            'C.初始rear和front的值分别是0和3，加入一个元素，针对的是rear指针，所以rear=1；删除两个元素，针对的是front指针，所以front=1；再加入三个元素，针对的是rear指针，所以rear=4；再删除一个元素，针对的是front指针，所以front=0。故rear=4，front=0'),



            ('用链式存储结构的队列进行插入、删除操作时需要（）',
            'A.仅修改头指针',
            'B.仅修改尾指针',
            'C.头尾指针都要修改',
            'D.头尾指针可能都要修改',4,
            'D.当链式队列插入一个元素时，若队列不为空时，只需要修改尾指针；而当队列为空时，头、尾指针都要修改。'),


            ('给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引. 那么下列算法的时间复杂度是？\n'+
             'def firstUniqChar(self, s: str) -> int:\n'+
             '    dic = {}\n'+
             '    for c in s:\n'+
             '        dic[c] = not c in dic\n'+
             '    for i, c in enumerate(s):\n'+
             '        if dic[c]: return i\n'+
             '    return -1',
            'A.O(N)',
            'B.O(1)',
            'C.O(N^2)',
            'D.O(N^3)',1,
            'A.N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N)O(N)O(N) ；HashMap 查找操作的复杂度为 O(1)O(1)O(1) 。'),


            ('一个 RecentCounter 类来计算特定时间范围内最近的请求。那么‘***’处的代码可以是\n'+
             'class RecentCounter:\n'+
             '     def __init__(self):\n'+
             '         self.queue = deque()\n'+
             '     def ping(self, t: int) -> int:\n'+
             '             ***'+
             '             self.queue.popleft()\n'+
             '         self.queue.append(t)\n'+
             '         return len(self.queue)\n',
            'A.while self.queue and self.queue[0] < t - 3000:',
            'B.for self.queue and self.queue[0] < t - 3000:',
            'C.while self.queue and self.queue[0] ',
            'D.if self.queue and self.queue[0] < t - 3000:',1,
            'A.就每次把超时的踢掉'),

            ('已知循环队列存储在一维数组A0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是( )。',
            'A.0，0',
            'B.0，n-1',
            'C.n-1, 0',
            'D. n-1，n-1',2,
            'B.'),


            ('最适合用做链队的链表是( )。',
            'A.带队首指针和队尾指针的循环单链表',
            'B.带队首指针和队尾指针的非循环单链表',
            'C.只带队首指针的非循环单链表',
            'D.只带队首指针的循环单链表',2,
            'B.'),



            ('最不适合用做链式队列的链表是( )。',
            'A.只带队首指针的非循环双链表',
            'B.只带队首指针的循环双链表',
            'C.只带队尾指针的循环双链表',
            'D.只带队尾指针的循环单链表',1,
            'A.'),


            ('用链式存储方式的队列进行删除操作时需要( )。',
            'A.仅修改头指针',
            'B.仅修改尾指针',
            'C.头尾指针都要修改',
            'D.头尾指针可能都要修改',4,
            'D.'),


            ('在一个链队列中，假设队头指针为front，队尾指针为rear, x所指向的元素需要入队，则需要执行的操作为( )。',
            'A.front=x，front= front->next',
            'B.x->next=front->next， front=x',
            'C.rear->next=x， rear=x',
            'D.rear->next=x， x->next=null， rear=x .',4,
            'D.'),


            ('对于队列操作数据的原则是()',
            'A.先进先出',
            'B.后进先出',
            'C.先进后出',
            'D.不分顺序',1,
            'A.'),


            ('队列中的元素个数是()',
            'A.不变的',
            'B.可变的',
            'C.任意的',
            'D.0',2,
            'B.');



insert into Linear(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('若长度为n的线性表采用顺序存储结构，在其第i个位置插入一个新元素算法的时间复杂度（）',
            'A.O(log2n)  ',
            'B.O(1)  ',
            'C.O(n)   ',
            'D.O(n^2)',3,
            'C.'),
            
            ('若一个线性表中最常用的操作是取第i个元素和找第i个元素的前趋元素，则采用（   ）存储方式最节省时间。',
            'A.顺序表         ',
            'B.单链表      ',
            'C.双链表     ',
            'D.单循环链表',1,
            'A.'),

            ('具有线性结构的数据结构是（   ）。',
            'A.图 ',
            'B.树      ',
            'C.广义表 ',
            'D.栈',4,
            'D. '),

            ('在一个长度为n的顺序表中，在第i个元素之前插入一个新元素时，需向后移动（   ）个元素。',
            'A.n-i      ',
            'B.n-i+1   ',
            'C.n-i-1',
            'D. i',2,
            'B. '),

            ('非空的循环单链表head的尾结点p满足（ ）',
            'A.p->next==head       ',
            'B. p->next==NULL    ',
            'C.p==NULL       ',
            'D.p==head',1,
            'A. '),

            ('链表不具有的特点是（   ）。',
            'A.可随机访问任一元素　',
            'B.插入删除不需要移动元素     ',
            'C.不必事先估计存储空间        ',
            'D.所需空间与线性表长度成正比',1,
            'A. '),

            ('在双向循环链表中，在p指针所指的结点后插入一个指针q所指向的新结点，修改指针的操作是（   ）',
            'A. p->next=q;q->prior=p;p->next->prior=q;q->next=q;',
            'B.p->next=q;p->next->prior=q;q->prior=p;q->next=p->next;  ',
            'C.q->prior=p;q->next=p->next;p->next->prior=q;p->next=q;  ',
            'D. q->next=p->next;q->prior=p;p->next=q;p->next=q;',3,
            'C. '),

            ('线性表采用链式存储时，结点的存储地址（   ）。',
            'A.必须是连续的      ',
            'B.必须是不连续的     ',
            'C.连续与否均可       ',
            'D.和头结点的存储地址相连续',3,
            'C. '),

            ('在一个长度为n的顺序表中删除第i个元素，需要向前移动（   ）个元素。',
            'A.n-i    ',
            'B. n-i+1   ',
            'C.n-i-1',
            'D.i+1',1,
            'A. '),

            ('线性表是n个（   ）的有限序列。',
            'A.表元素',
            'B.字符',
            'C.数据元素',
            'D.数据项 ',3,
            'C. '),

            ('从表中任一结点出发，都能扫描整个表的是()',
            'A.单链表 ',
            'B.顺序表      ',
            'C. 循环链表 ',
            'D.静态链表',3,
            'C. '),

            ('在具有n个结点的单链表上查找值为x的元素时，其时间复杂度为（   ）',
            'A.O(n)',
            'B.O(1) ',
            'C.O(n2) ',
            'D.O(n-1)',1,
            'A. '),

            ('链栈与顺序栈相比，比较明显的优点是()',
            'A.插入操作更加方便',
            'B.删除操作更加方便',
            'C.入栈时不需要扩容',
            'D.我不到啊',3,
            'C.入栈时不需要扩容 每次入栈相当于链表中头插一个节点，没有扩容一说'),

            ('线性表L=(a1,a2,……,an)，下列说法正确的是（   ）',
            'A.每个元素都有一个直接前驱和一个直接后继         ',
            'B.线性表中至少要有一个元素',
            'C.表中诸元素的排列顺序必须是由小到大或由大到小 ',
            'D.除第一个和最后一个元素外，其余每个元素都由一个且仅有一个直接前驱和直接后继',3,
            'D. '),

            ('一个顺序表的第一个元素的存储地址是90，每个元素的长度为2，则第6个元素的存储地址是（   ）。',
            'A.98',
            'B.100',
            'C.102',
            'D.106 ',2,
            'B. '),

            ('在线性表的下列存储结构中，读取元素花费的时间最少的是（   ）。',
            'A.单链表   ',
            'B.双链表   ',
            'C.循环链表      ',
            'D.顺序表',4,
            'D. ');



insert into String(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values


            ('下面关于串的叙述中，正确的是（ ）',
            'A.串是一种特殊的线性表',
            'B.串中元素只能是字母',
            'C.空串就是空白串',
            'D.串的长度必须大于零',1,
            'A.解析:串是一种特殊的线性表，其元素为单个字符，长度可以为0。'),

            ('两个字符串相等的条件是（ ）',
            'A.串的长度相等',
            'B.含有相同的字符集',
            'C.都是非空串',
            'D.两个串的长度相等且对应位置的字符相同',4,
            'D. '),

            ('若串str=“Software”，其子串的个数是（ ）',
            'A.8',
            'B.9',
            'C.36',
            'D.37',4,
            'D.解析：  该串中所有字符不相同，长度为0的子串1个，长度为1的子串8个，长度为2的子串7个，…，长度为7的子串2个，长度为8的子串1个，总计子串数=1+8+7+…+2+1=1+8×9/2=37。'),

            ('串采用节点大小为1的链表作为其存储结构，是指（ ）',
            'A.链表的长度为1',
            'B.链表中只存放一个字符',
            'C.链表中每个节点的数据域中只存放一个字符',
            'D.以上都不对',3,
            '解析：  C、链串节点大小指每个节点存放的字符个数。'),

            ('对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。',
            'A.O(1)',
            'B.O(n)',
            'C.O(n^2)',
            'D.我不到啊',3,
            '解析：在链串查找第一个字符值为x的算法的时间复杂度为O(n)。'),

            ('7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。',
            'A.求子串',
            'B.串联接',
            'C.模式匹配',
            'D.求串长',3,
            '解析：模式匹配算法就是找子串在主串中的位置。'),

            ('在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。',
            'A.i=next[j]',
            'B.i不变',
            'C.j不变',
            'D.我不到啊',3,
            '解析:在KMP模式匹配中，当两字符比较不等时，目标串位i不回溯，仍停留在原来的位置。'),

            ('访问字符串中的部分字符的操作称为（）',
            'A.分片',
            'B.合并 ',
            'C.索引 ',
            'D.赋值',1,
            'A.大致就是用这样一个格式，s是字符串---s[i:j:k]'),

            ('下列关于字符串的描述错误的是（）。',
            'A.字符串s的首字符是s[0]',
            'B.在字符串中，同一个字母的大小是等价的。',
            'C.字符串中的字符都是以某种二进制编码的方式进行存储和处理的',
            'D.字符串也能进行关系比较操作',3,
            'B. '),

            ('下列表达式中，有3个表达式的值相同，另一个不相同，与其他3个表达式不同的是()',
            'A."ABC"+"DEF"   ',
            'B.join(("ABC","DEF")) ',
            'C."ABC"-"DEF" ',
            'D."ABCDEF"*1',3,
            'C. '),

            ('设s="Python Programming"，那么print(s[-5:])的结果是()',
            'A.mming    ',
            'B.Python',
            'C.mmin ',
            'D.Pytho',1,
            'A.从下标为-5的字符开始，到字符串最后一个字符'),

            ('设s="Happy New Year"，则s[3:8]的值为()',
            'A.ppy Ne  ',
            'B.py Ne',
            'C.ppy N',
            'D.py New',B,
            '不包括下标为8的字符'),

            ('将字符串中全部字母转换为大写字母的字符串方法是()',
            'A.swapcase  ',
            'B.capitalize  ',
            'C.uppercase    ',
            'D.upper ',3,
            ' D'),

           
            ('以下哪个方法可以用于判断一个字符串是否以指定的字符开头？()',
            'A.startswith()',
            'B.endswith()',
            'C.upper()',
            'D.lower()',1,
            '解析: startswith() 方法用于检查一个字符串是否以指定的字符开头。endswith() 方法用于检查一个字符串是否以指定的字符结尾。upper() 方法用于将字符串转换为大写，lower() 方法用于将字符串转换为小写。'),

            ('以下哪个方法可以用于将一个字符串分割成多个子字符串，并返回一个列表？',
            'A.split()',
            'B.join()',
            'C.replace()',
            'D.find()',1,
            '.split() 方法可以根据指定的分隔符将一个字符串分割成多个子字符串，并返回一个由子字符串组成的列表。join() 方法用于将列表中的字符串连接成一个字符串。replace() 方法用于替换字符串中的指定子字符串。find() 方法用于在字符串中查找指定子字符串的位置。'),

            ('以下哪个方法可以用于去除字符串两端的空白字符（包括空格、制表符、换行符等）？',
            'A.replace()',
            'B. strip()',
            'C.find()',
            'D.我不到啊',3,
            'strip() 方法可以去除字符串两端的空白字符，包括空格、制表符、换行符等。replace() 方法用于替换字符串中的指定子字符串。find() 方法用于在字符串中查找指定子字符串的位置。upper() 方法用于将字符串转换为大写。'),

            
            ('以下哪个方法可以用于将一个字符串的字符顺序反转？()',
            'A.find()',
            'B.split()',
            'C.replace()',
            'D.我不到啊',3,
            'C. replace() 方法可以将一个字符串中的指定子字符串替换为新的字符串。');



insert into Btree(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('二叉树的特点是什么？',
            'A.每个节点最多有两个子节点',
            'B.每个节点最多有三个子节点',
            'C.每个节点最多有四个子节点',
            'D.每个节点最多有五个子节点',1,
            '解析：二叉树是一种数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。'),

            ('在二叉树中，如果一个节点没有子节点，则称之为：',
            'A.叶节点',
            'B.根节点',
            'C.中间节点',
            'D.空节点',1,
            '解析：叶节点是指没有子节点的节点，也称为终端节点或叶子节点。'),

            ('以下哪种遍历方式可以按照从小到大的顺序输出二叉搜索树中的节点值？',
            'A.先序遍历',
            'B.中序遍历',
            'C.后序遍历',
            'D.层序遍历',2,
            '中序遍历是指先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历的结果是节点值按从小到大的顺序排列'),

            ('以下哪种遍历方式可以用于复原一棵二叉树？',
            'A.先序遍历',
            'B.层序遍历',
            'C.后序遍历',
            'D.我不到啊',1,
            '解析：通过先序遍历和中序遍历的结果，可以唯一确定一棵二叉树的结构。其他遍历方式不能唯一确定二叉树的结构。'),

            ('二叉树的深度等于：',
            'A.根节点的高度',
            'B.叶节点的高度',
            'C.最大子树的高度+1',
            'D.所有节点的高度之和',3,
            '解析：二叉树的深度等于它最大子树的深度加1。根节点的深度为0。'),

            ('在二叉树中，左子树和右子树的节点数相差不超过1的二叉树称为：',
            'A.完全二叉树',
            'B.平衡二叉树',
            'C.满二叉树',
            'D.红黑树',2,
            '解析：平衡二叉树是指左子树和右子树的高度差不超过1的二叉树。'),

            ('以下哪种二叉树中，每个节点要么没有子节点，要么有两个子节点？',
            'A.完全二叉树',
            'B.二叉搜索树',
            'C.满二叉树',
            'D.平衡二叉树',3,
            '解析：满二叉树是指除最后一层外，每一层上的所有节点都有两个子节点。'),

            ('二叉搜索树（BST）的特点是什么？()',
            'A.左子节点的值小于根节点的值，右子节点的值大于根节点的值',
            'B.左子节点的值大于根节点的值，右子节点的值小于根节点的值',
            'C.左子节点的值等于根节点的值，右子节点的值大于根节点的值',
            'D.左子节点的值小于根节点的值，右子节点的值等于根节点的值',1,
            '解析：二叉搜索树是一种特殊的二叉树，满足左子节点的值小于根节点的值，右子节点的值大于根节点的值的条件'),

            ('以下哪种二叉树可以用于高效地对数据进行排序和查找？',
            'A.完全二叉树',
            'B.二叉搜索树',
            'C.平衡二叉树',
            'D.红黑树',2,
            '解析：二叉搜索树具有排序特性，可以高效地进行数据的插入、删除、搜索和排序操作。'),

            ('二叉树的遍历方式有几种？()',
            'A.2',
            'B.3',
            'C.4',
            'D.5',3,
            '解析：二叉树的遍历方式包括先序遍历、中序遍历、后序遍历和层序遍历。'),

            ('在二叉树的先序遍历中，根节点的访问顺序是：',
            'A.先访问左子节点，再访问右子节点，最后访问根节点',
            'B.先访问右子节点，再访问左子节点，最后访问根节点',
            'C.先访问根节点，再访问左子节点，最后访问右子节点',
            'D.先访问根节点，再访问右子节点，最后访问左子节点',3,
            'C. '),

            ('二叉树的平均查找时间复杂度是多少？()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.我不到啊',3,
            '在二叉搜索树中，平均查找时间复杂度约为O(log n)，其中n为节点的数量。'),

            ('二叉树的最大深度可以通过以下哪种遍历方式求得？()',
            'A.先序遍历',
            'B.中序遍历',
            'C.后序遍历',
            'D.我不到啊',3,
            '解析：在后序遍历中，最后一个被访问的节点一定是根节点，可以通过记录每个节点的深度来求得二叉树的最大深度。'),

            ('二叉树的最小深度可以通过以下哪种遍历方式求得？()',
            'A.先序遍历',
            'B.中序遍历',
            'C.后序遍历',
            'D.层序遍历',4,
            '解析：层序遍历可以按层次逐层访问节点，因此可以通过记录每个节点的深度来求得二叉树的最小深度。'),

            ('二叉树的直径指的是：()',
            'A.二叉树的高度',
            'B.二叉树的节点数',
            'C.二叉树中任意两个节点之间的最长路径长度',
            'D.二叉树中任意两个节点之间的最短路径长度',3,
            '解析：二叉树的直径是指二叉树中任意两个节点之间的最长路径长度，可以通过遍历二叉树的每个节点来求得'),

            ('二叉树的镜像是指：()',
            'A.交换二叉树的左右子树',
            'B.删除二叉树的叶节点',
            'C.将二叉树的节点值按照从大到小排列',
            'D. 将二叉树的节点值按照从小到大排列',1,
            '解析：二叉树的镜像是指将二叉树的左右子树进行交换，得到的树与原二叉树关于根节点对称。'),

            ('在二叉树的层序遍历中，根节点的访问顺序是()',
            'A.先访问左子节点，再访问右子节点，最后访问根节点',
            'B.先访问右子节点，再访问左子节点，最后访问根节点',
            'C.先访问根节点，再访问左子节点，最后访问右子节点',
            'D.先访问根节点，再访问右子节点，最后访问左子节点',3,
            '解析：在层序遍历中，按照从上到下、从左到右的顺序依次访问每个节点。');



insert into Multarray(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('什么是多维数组？',
            'A.由相同类型的元素组成的一维数组',
            'B.由不同类型的元素组成的一维数组',
            'C. 由相同类型的元素组成的多维数组',
            'D.由不同类型的元素组成的多维数组',3,
            'C.多维数组是由相同类型的元素组成的，可以有多个维度的数组。'),

            ('以下哪个选项是多维数组的定义方式？',
            'A.[1, 2, 3]',
            'B.[[1, 2, 3], [4, 5, 6]]',
            'C.(1, 2, 3)',
            'D.{1, 2, 3}',2,
            'B.多维数组可以使用方括号来定义，每个维度使用逗号分隔。'),

            ('以下哪个选项是多维数组的访问方式？',
            'A.array[0]',
            'B.array[0, 1]',
            'C.array[0][1]',
            'D.array(0, 1)',3,
            '解析: 多维数组的访问方式是通过使用多个索引值，按照维度的顺序进行访问。'),

            ('以下哪个选项用于获取多维数组的维度（维数）()',
            'A.len(array)',
            'B.array.ndim',
            'C.array.shape',
            'D.array.size',2,
            '解析: 多维数组的维度可以使用 .ndim 属性来获取。len(array) 返回数组的第一个维度的大小。'),

            ('以下哪个选项用于修改多维数组的形状？',
            'A.array.reshape()',
            'B.array.resize()',
            'C.array.flatten()',
            'D.array.transpose()',1,
            '解析: array.reshape() 方法用于修改多维数组的形状，'),

            ('以下哪个选项用于在多维数组中插入新的轴？',
            'A.array.expand_dims()',
            'B.array.insert()',
            'C.array.append()',
            'D.array.concatenate()',1,
            '解析: array.expand_dims() 方法用于在多维数组中插入新的轴，'),

            ('以下哪个选项用于沿指定轴对多维数组进行排序？',
            'A.array.sort()',
            'B.array.argsort()',
            'C.array.sort(axis=0)',
            'D.array.sort(axis=None)',3,
            '解析: array.sort(axis=0) 方法用于沿指定轴对多维数组进行排序。'),

            ('以下哪个选项用于计算多维数组的和？',
            'A. array.sum()',
            'B.array.mean()',
            'C.array.max()',
            'D.array.min()',1,
            '解析: array.sum() 方法用于计算多维数组的和。'),

            ('以下哪个选项用于逐元素地对多维数组进行运算？',
            'A.array.add()',
            'B.array.subtract()',
            'C.array.multiply()',
            'D.array.divide()',1,
            '解析: array.add() 方法用于逐元素地对多维数组进行加法运算。'),

            ('以下哪个选项用于计算多维数组的平均值？',
            'A. array.sum()',
            'B.array.mean()',
            'C.array.max()',
            'D.array.min()',2,
            '解析: array.mean() 方法用于计算多维数组的平均值。'),

            ('以下哪个选项用于将多维数组展平为一维数组？',
            'A.array.flatten(',
            'B.array.reshape()',
            'C.array.squeeze()',
            'D.array.transpose()',1,
            '解析: array.flatten() 方法用于将多维数组展平为一维数组。'),

            ('以下哪个选项用于在多维数组中沿指定轴进行求和？',
            'A.array.sum()',
            'B.array.mean()',
            'C.array.max()',
            'D.array.sum(axis=0)',4,
            '解析: array.sum(axis=0) 方法用于在多维数组中沿指定轴进行求和。'),

            ('以下哪个选项用于将多个多维数组沿指定轴进行连接？',
            'A.array.concatenate()',
            'B.array.stack()',
            'C.array.append()',
            'D.array.insert()',1,
            '解析: array.concatenate() 方法用于将多个多维数组沿指定轴进行连接。'),

            ('以下哪个选项用于获取多维数组中指定轴的最大值？',
            'A.array.max()',
            'B.array.min()',
            'C.array.argmax()',
            'D.我不到啊',3,
            '解析: array.max() 方法用于获取多维数组的最大值。'),

            ('以下哪个选项用于获取多维数组中指定轴的最小值？',
            'A.array.max()',
            'B.array.min()',
            'C.array.argmin()',
            'D.我不到啊',3,
            'array.max() 方法用于获取多维数组的最大值。array.min() 方法用于获取多维数组的最小值。array.argmax() 方法用于获取指定轴上的最大值的索引。array.argmin() 方法用于获取指定轴上的最小值的索引。'),

            ('以下哪个选项用于计算多维数组中元素的累积和？',
            'A.array.sum()',
            'B.array.cumsum()',
            'C.array.mean()',
            'D.array.prod()',2,
            'array.cumsum() 方法用于计算多维数组中元素的累积和。'),

            ('以下哪个选项用于计算多维数组中元素的累积乘积？',
            'A.array.sum()',
            'B.array.mean()',
            'C.array.prod()',
            'D.我不到啊',3,
            'C. '),

            ('以下哪个选项用于将多维数组转置？',
            'A.array.transpose()',
            'B.array.swapaxes()',
            'C.array.reshape()',
            'D.array.flatten()',1,
            '解析: array.transpose() 方法用于将多维数组转置，即交换数组的维度。');

           
           
insert into Htree(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('哈夫曼树是一种用来做什么的数据结构？()',
            'A.数据压缩',
            'B.数据加密',
            'C.数据排序',
            'D.数据查询',31,
            '解析：哈夫曼树通常用于数据压缩，通过构建最优的前缀编码来减少数据存储空间。'),

            ('哪种类型的树被用来构建哈夫曼树？()',
            'A.二叉搜索树',
            'B.平衡树',
            'C.二叉树',
            'D.完全二叉树',3,
            '解析：哈夫曼树是基于二叉树的数据结构，它由一组权重给定的叶子节点构成。'),

            ('在构建哈夫曼树时，哪种节点会被优先合并？()',
            'A.权重最小的叶子节点',
            'B.权重最大的叶子节点',
            'C.权重相等的叶子节点',
            'D.随机选择的叶子节点',3,
            '解析：在构建哈夫曼树时，权重最小的叶子节点会被优先合并，以确保生成最优的编码。'),

            ('哪种操作会导致哈夫曼树的重构？()',
            'A.插入新节点',
            'B.删除节点',
            'C.更新节点权重',
            'D.以上都是',4,
            '解析：插入、删除或更新节点的权重都可能导致哈夫曼树的重构，以保持最优编码的特性。'),

            ('哪种情况下哈夫曼编码会更有效？',
            'A.数据中包含大量重复的字符',
            'B.数据均匀分布',
            'C.数据量较小',
            'D.我不到啊',1,
            '解析：哈夫曼编码在处理包含大量重复字符的数据时表现更为高效，因为它可以用较短的编码表示频繁出现的字符。'),

            ('哈夫曼树的带权路径长度是指什么？()',
            'A.树中所有节点的路径长度之和',
            'B.树中所有节点的权值之和',
            'C.树中所有叶子节点的路径长度之和',
            'D.树中所有非叶子节点的路径长度之和',3,
            '解析：哈夫曼树的带权路径长度是指所有叶子节点的路径长度与其对应权值的乘积之和。'),

            ('哈夫曼树的带权路径长度最小的特点使得它成为一种什么样的树？()',
            'A. 最优树',
            'B. 平衡树',
            'C.满二叉树',
            'D.二叉搜索树',1,
            '解析：哈夫曼树因其带权路径长度最小的特点而成为一种最优树，适合用于数据压缩和编码。'),

            ('哪种情况下哈夫曼树的构建会变得更为复杂？()',
            'A.只有少量字符需要编码',
            'B.字符集中包含大量不同的字符',
            'C.所有字符的权重相等',
            'D.字符的权重呈指数增长',2,
            '解析：当字符集中包含大量不同的字符时，哈夫曼树的构建会变得更为复杂，因为需要考虑更多的叶子节点。'),

            ('哪种算法通常用于构建哈夫曼树？()',
            'A.深度优先搜索',
            'B.广度优先搜索',
            'C.贪心算法',
            'D.动态规划',3,
            '解析：通常使用贪心算法来构建哈夫曼树，通过反复选择当前权重最小的节点进行合并来逐步构建整棵树。'),

            ('哈夫曼树在数据压缩中的优势体现在哪里？()',
            'A.提高数据传输速度',
            'B.减少存储空间占用',
            'C.加密数据安全性',
            'D. 提高数据处理效率',2,
            '解析：哈夫曼树通过最优编码来减少数据存储空间占用，是数据压缩的有效工具。'),

            ('哪种应用场景不适合使用哈夫曼树进行数据压缩？()',
            'A.图像文件',
            'B.音频文件',
            'C.文本文件',
            'D.视频文件',4,
            '解析：哈夫曼树在处理视频文件等已经经过压缩处理的数据时效果有限，不如在处理原始数据时那样显著。'),

            ('哪种情况下哈夫曼编码可能会出现编码冲突？()',
            'A.所有叶子节点的权重相等',
            'B.只有两个叶子节点',
            'C.数据中只包含唯一的字符',
            'D.数据量较小',1,
            '解析：当所有叶子节点的权重相等时，哈夫曼编码可能会出现编码冲突，降低了编码效率。'),

            ('哪种操作可以改变哈夫曼树的结构而不会改变编码结果？()',
            'A.交换叶子节点位置',
            'B. 改变非叶子节点的权重',
            'C.删除叶子节点',
            'D. 添加新的叶子节点',32,
            '解析：改变非叶子节点的权重可以改变哈夫曼树的结构，但不会改变编码结果。'),

            ('哪种情况下哈夫曼编码是唯一的？()',
            'A.所有字符的权重各不相同',
            'B.所有字符的权重相等',
            'C. 数据量很大',
            'D.数据类型不影响哈夫曼编码的唯一性',1,
            '解析：当所有字符的权重各不相同时，哈夫曼编码是唯一的；权重相等时，哈夫曼编码可能有多种组合。'),

            ('哪种情况下哈夫曼编码的平均编码长度达到最优？()',
            'A.满二叉树',
            'B.完全二叉树',
            'C.平衡二叉树',
            'D.哈夫曼树',4,
            '解析：哈夫曼树具有最优的平均编码长度，比其他树形结构更能节省编码长度。'),

            ('哪种方法可以用于存储哈夫曼树的结构？()',
            'A.先序遍历和中序遍历',
            'B.层次遍历',
            'C.后序遍历',
            'D.中序遍历',1,
            '解析：通过先序遍历和中序遍历可以完整记录哈夫曼树的结构。'),

            ('哪种操作可以使哈夫曼编码实现前缀码的特性？()',
            'A.将编码结果反转',
            'B.在编码中加入特殊标记',
            'C.调整权重分布',
            'D.无需额外操作，哈夫曼编码本身即为前缀码',4,
            '解析：哈夫曼编码本身具有前缀码的特性，不需要额外的操作来实现。'),

            ('哪种情况下哈夫曼树只有一个节点？()',
            'A.空数据集',
            'B.单个字符的数据集',
            'C. 数据集中只包含相同字符',
            'D.数据集中只包含两种字符',2,
            '解析：当数据集中只包含一个字符时，哈夫曼树只有一个节点。');


            
insert into Ungraphs(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('无向图是一种由一组_________和一组_________组成的图结构。()',
            'A.顶点，边',
            'B.边，路径',
            'C.路径，顶点',
            'D.顶点，路径',1,
            '解析：无向图由一组顶点和一组边组成，边连接顶点之间的关系。'),

            ('无向图中的边是否有方向？()',
            'A.有方向',
            'B.无方向',
            'C.可以有方向，也可以没有方向',
            'D.边的方向与具体情况相关',2,
            '解析：无向图的边没有方向，表示连接的两个顶点没有特定的起始点和终点。'),

            ('无向图的边是否具有权重？()',
            'A.是，具有权重',
            'B. 否，没有权重',
            'C.可以有权重，也可以没有权重',
            'D.边的权重与具体情况相关',3,
            '解析：无向图的边可以有权重，也可以没有权重，取决于具体应用场景。'),

            ('无向图中任意两个顶点之间是否存在多条边？()',
            'A.是，可以存在多条边',
            'B.否，只能存在一条边',
            'C.可以存在多条边，也可以只存在一条边',
            'D.边的数量与具体情况相关',1,
            '解析：无向图中任意两个顶点之间可以存在多条边，表示它们之间有多种关系。'),

            ('无向图中有多少个顶点和边可以构成一个孤立的顶点？()',
            'A.1个顶点，0条边',
            'B.0个顶点，1条边',
            'C.1个顶点，1条边',
            'D.0个顶点，0条边',1,
            '解析：一个孤立的顶点是指在无向图中只有一个顶点，且没有与其他顶点相连的边。'),

            ('无向图中的度定义为什么？()',
            'A.顶点的个数',
            'B.边的个数',
            'C.顶点相邻边的数量',
            'D.边的权重之和',3,
            '解析：无向图中的度是指一个顶点相邻边的数量，表示与该顶点直接相连的边的个数。'),

            ('无向图中的度的最大值和最小值分别是多少？()',
            'A.最大值为顶点数，最小值为0',
            'B.最大值为边数，最小值为0',
            'C.最大值为顶点数-1，最小值为0',
            'D.最大值为边数-1，最小值为0',3,
            '解析：在无向图中，一个顶点的度的最大值为顶点数-1（当它与图中的所有其他顶点都相连时），最小值为0（当它没有与其他顶点相连时）。'),

            ('无向图中的完全图是指什么？()',
            'A.所有顶点之间都有边相连',
            'B.所有顶点的度均为奇数',
            'C.所有顶点的度均为偶数',
            'D.所有顶点之间没有边相连',1,
            '解析：无向图中的完全图是指图中的每个顶点与其他所有顶点都有边相连。'),

            ('无向图中的桥是指什么？()',
            'A.连接两个孤立的顶点的边',
            'B.连接两个连通分量的边',
            'C.连接度为0的顶点的边',
            'D.连接度为2的顶点的边',2,
            '解析：无向图中的桥是指连接两个连通分量的边，去掉它后图会变成不连通。'),

            ('无向图中的割点是指什么？()',
            'A. 孤立的顶点',
            'B.连接两个连通分量的顶点',
            'C.可以使图变成不连通的顶点',
            'D.所有顶点均为割点',3,
            '解析：在无向图中，一个顶点如果被删去后，图会变成不连通，则称该顶点为割点。'),

            ('链栈与顺序栈相比，比较明显的优点是()',
            'A.插入操作更加方便',
            'B.删除操作更加方便',
            'C.入栈时不需要扩容',
            'D.我不到啊',3,
            'C.入栈时不需要扩容 每次入栈相当于链表中头插一个节点，没有扩容一说'),

            ('无向图的生成树是什么？()',
            'A.一棵包含所有顶点的树',
            'B.一棵包含部分顶点的树',
            'C. 一棵包含所有边的树',
            'D.一棵包含部分边的树',3,
            '解析：无向图的生成树是指包含图中所有顶点和一部分边的树，其中，边的数量为顶点数量-1。'),

            ('如何判断无向图是否连通？()',
            'A.判断是否存在孤立顶点',
            'B.判断是否存在度为0的顶点',
            'C. 判断是否存在桥',
            'D. 判断是否存在割点',1,
            '解析：一个无向图是连通的，当且仅当它不存在孤立的顶点。'),

            ('如果通过一条边将一个连通图分成两个连通子图，这条边被称为什么？()',
            'A.桥',
            'B.割点',
            'C.环',
            'D.生成树',1,
            '解析：如果一条边被删除后，将一个连通图分成了两个连通子图，则该边被称为桥。'),

            ('无向图中的欧拉回路是什么？()',
            'A.包含所有顶点的回路',
            'B.包含所有边的回路',
            'C.从一个顶点出发，遍历图中所有边恰好一次的回路',
            'D.所有顶点的度均为偶数的回路',2,
            '解析：无向图中的欧拉回路是指包含图中所有边的回路，其中，每条边都恰好被遍历一次。'),

            ('无向图中的欧拉通路是什么？()',
            'A.包含所有顶点的路径',
            'B.包含所有边的路径',
            'C.从一个顶点出发，遍历图中所有边恰好一次的路径',
            'D.所有顶点的度均为偶数的路径',3,
            '解析：无向图中的欧拉通路是指从一个顶点出发，遍历图中所有边恰好一次的路径。'),

            ('无向图中的哈密顿回路是什么？()',
            'A.包含所有顶点的回路',
            'B.包含所有边的回路',
            'C.包含所有顶点的路径',
            'D. 包含所有边的路径',1,
            '解析：无向图中的哈密顿回路是指包含图中所有顶点的回路，其中，每个顶点都恰好被访问一次。'),

            ('无向图中的哈密顿路径是什么？()',
            'A.包含所有顶点的路径',
            'B.包含所有边的路径',
            'C.包含所有顶点的回路',
            'D.包含所有边的回路',1,
            '解析：无向图中的哈密顿路径是指包含图中所有顶点的路径，其中，每个顶点都恰好被访问一次。');



insert into Dgraphs(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('有向图是一种由一组_________和一组_________组成的图结构。()',
            'A.顶点，边',
            'B.边，路径',
            'C.路径，顶点',
            'D.顶点，路径',31,
            '解析：有向图由一组顶点和一组有方向的边组成，边表示顶点之间的单向关系。'),

            ('有向图中的边具有方向，即从一个顶点指向另一个顶点。()',
            'A.对',
            'B.错',
            'C.无法判断',
            'D.我不到啊',1,
            '解析：在有向图中，边具有方向，表示从一个顶点指向另一个顶点的关系。'),

            ('有向图中的度定义为什么？()',
            'A.顶点的个数',
            'B.入度和出度之和',
            'C.边的个数',
            'D. 顶点相邻边的数量',2,
            '解析：有向图中的度包括入度和出度，入度表示指向该顶点的边的数量，出度表示由该顶点指出的边的数量。'),

            ('有向图中的度的最大值和最小值分别是多少？()',
            'A.最大值为顶点数-1，最小值为0',
            'B.最大值为顶点数，最小值为0',
            'C.最大值为边数-1，最小值为0',
            'D.最大值为边数，最小值为0',2,
            '解析：在有向图中，一个顶点的最大出度为顶点数，最小为0；最大入度也为顶点数，最小也为0。'),

            ('有向图中的强连通分量是什么？()',
            'A.互相不可达的顶点集合',
            'B.任意两个顶点都可达的顶点集合',
            'C.不能形成环路的顶点集合',
            'D.入度和出度相等的顶点集合',2,
            '解析：在有向图中，强连通分量是指任意两个顶点都可达对方的顶点集合，即其中的任意两个顶点之间存在双向路径。'),

            ('有向图的生成树是指什么？()',
            'A.包含所有顶点的树',
            'B.包含所有边的树',
            'C.包含部分顶点和所有边的树',
            'D.包含部分边和所有顶点的树',3,
            '解析：有向图的生成树是指包含图中所有顶点和一部分边的树，其中，边的数量为顶点数量-1。'),

            ('如何判断有向图是否强连通？()',
            'A.判断是否存在孤立顶点',
            'B.判断是否存在度为0的顶点',
            'C.判断是否存在桥',
            'D.判断是否存在强连通分量',3,
            '解析：一个有向图是强连通的，当且仅当它不存在互相不可达的顶点集合，即不存在强连通分量。'),

            ('如果通过一条边将一个有向图中的某些顶点变成不可达，这条边被称为什么？()',
            'A.桥',
            'B.割点',
            'C.环',
            'D.我不到啊',1,
            '解析：在有向图中，如果一条边被删除后，会导致某些顶点变成不可达，则该边被称为桥。'),

            ('有向图中的拓扑排序是什么？()',
            'A.一种排列顶点的方法',
            'B.一种排列边的方法',
            'C.一种排列顶点和边的方法',
            'D.一种排列强连通分量的方法',1,
            '解析：有向图的拓扑排序是指将图中所有顶点排成线性序列，使得对图中的每条有向边 (u, v)，在序列中顶点 u 出现在顶点 v 之前。'),

            ('有向图中的环路是指什么？()',
            'A.一种特殊的强连通分量',
            'B.一种特殊的拓扑排序',
            'C.一种特殊的连通子图',
            'D.一种特殊的路径',3,
            '解析：在有向图中，环路是指强连通分量中的一种特殊情况，其中存在形成环状的路径。'),

            ('有向图中的反向图是指什么？()',
            'A.将所有边的方向取反得到的图',
            'B.将所有顶点的入度和出度互换得到的图',
            'C.顶点的集合不变，边的集合改变得到的图',
            'D.边的权重取负得到的图',1,
            '解析：有向图的反向图是指将原图中所有边的方向取反得到的图。'),

            ('有向图中的传递闭包是什么？()',
            'A.一种特殊的拓扑排序',
            'B.一种特殊的拓扑序列',
            'C.一种特殊的关系闭包',
            'D.一种特殊的强连通分量',3,
            '解析：在有向图中，传递闭包表示图中所有顶点之间的直接或间接关系构成的闭包，即若存在一条路径从顶点 i 到顶点 j，则 j 与 i 存在传递关系。'),

            ('有向图中的最小路径是指什么？()',
            'A.从一个顶点到另一个顶点的路径中，权重之和最小的路径',
            'B.从一个顶点到另一个顶点的路径中，长度最短的路径',
            'C.从一个顶点到另一个顶点的路径中，边的数量最少的路径',
            'D.从一个顶点到另一个顶点的路径中，总代价最小的路径',1,
            'C. '),

            ('有向图中的最大路径是指什么？()',
            'A.从一个顶点到另一个顶点的路径中，权重之和最大的路径',
            'B.从一个顶点到另一个顶点的路径中，长度最长的路径',
            'C.从一个顶点到另一个顶点的路径中，边的数量最多的路径',
            'D.从一个顶点到另一个顶点的路径中，总代价最大的路径',1,
            '解析：有向图中的最大路径是指从一个顶点到另一个顶点的路径中，其边上权重之和最大的路径。'),

            ('有向图中的费马小定理是指什么？()',
            'A.一种用来判断有向图是否存在欧拉路径的定理',
            'B.一种用来判断有向图是否存在哈密顿路径的定理',
            'C.一种用来判断有向图是否存在拓扑排序的定理',
            'D.一种用来判断有向图的连通性的定理',4,
            '解析：费马小定理是一种用来判断有向图的连通性的定理，它可以从入度和出度的角度判断图的连通性。'),

            ('有向图中的弱连通分量是什么？()',
            'A. 互相不可达的顶点集合',
            'B. 任意两个顶点都可达的顶点集合',
            'C.不能形成环路的顶点集合',
            'D.入度和出度相等的顶点集合',2,
            'C. '),

            ('有向图中的最小强连通子图是什么？()',
            'A.包含所有顶点的子图',
            'B.包含所有边的子图',
            'C.包含所有顶点和所有边的子图',
            'D.包含部分顶点和所有边的子图',3,
            '解析：有向图中的最小生成树是指包含图中所有顶点和一部分边的生成树，其中，边的数量至少为顶点数量-1。');



insert into GraphT(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('以下哪种算法可以用于图的遍历？()',
            'A.深度优先搜索（DFS）',
            'B.快速搜索',
            'C.迪杰斯特拉算法',
            'D.克鲁斯卡尔算法',1,
            '深度优先搜索（DFS）和广度优先搜索（BFS）都可以用于图的遍历。'),

            ('在深度优先搜索过程中，以下哪个数据结构通常被使用？()',
            'A.栈',
            'B.队列',
            'C.数组',
            'D.堆',1,
            '在深度优先搜索中，常使用栈（Stack）这一数据结构来保存待访问的节点。深度优先搜索是通过递归或显式栈来实现的。'),

            ('以下关于广度优先搜索（BFS）的说法正确的是()',
            'A.BFS使用队列作为辅助数据结构',
            'B.BFS总是能找到最短路径',
            'C.BFS适用于有权图',
            'D.BFS的时间复杂度较高',1,
            ' 说'),

            ('以下哪个算法可以用于计算图中两个节点之间的最短路径？()',
            'A.迪杰斯特拉算法',
            'B.克鲁斯卡尔算法',
            'C.深度优先搜索（DFS）',
            'D.我不到啊',1,
            '迪杰斯特拉算法可以用于计算图中两个节点之间的最短路径。'),

            ('对于一个有向图，以下哪种遍历算法能够访问到所有可达的节点？()',
            'A.深度优先搜索（DFS）',
            'B.广度优先搜索（BFS）',
            'C.迪杰斯特拉算法',
            'D.克鲁斯卡尔算法',1,
            '解析：深度优先搜索（DFS）可以访问到有向图中的所有可达节点。'),

            ('以下哪种情况下使用深度优先搜索（DFS）比广度优先搜索（BFS）更合适？()',
            'A.查找图中的最短路径',
            'B.寻找图中的环路',
            'C.计算最小生成树',
            'D.判断图的连通性',2,
            '深度优先搜索（DFS）比广度优先搜索（BFS）更适用于寻找图中的环路。'),

            ('在广度优先搜索（BFS）过程中，每个节点最多会被访问几次？()',
            'A.0',
            'B.1',
            'C.2',
            'D.我不到啊',2,
            '在广度优先搜索（BFS）过程中，每个节点最多会被访问一次。'),

            ('以下哪个算法可以用于计算图的最小生成树？()',
            'A.迪杰斯特拉算法',
            'B.克鲁斯卡尔算法',
            'C.深度优先搜索（DFS)',
            'D.广度优先搜索（BFS）',2,
            '解析：克鲁斯卡尔算法可以用于计算图的最小生成树。'),

            ('在深度优先搜索（DFS）过程中，以下哪个数据结构被使用来记录已访问节点？()',
            'A.栈',
            'B.队列',
            'C.数组',
            'D.堆',3,
            'C.解析：在深度优先搜索中，通常使用数组（Array）或哈希表等数据结构来记录已访问的节点，以避免重复访问。'),

            ('以下哪种情况下使用广度优先搜索（BFS）比深度优先搜索（DFS）更合适？()',
            'A.查找图中的最短路径',
            'B.寻找图中的环路',
            'C.计算最小生成树',
            'D.判断图的连通性',1,
            '广度优先搜索（BFS）比深度优先搜索（DFS）更适合用于查找图中的最短路径。'),

            ('在深度优先搜索（DFS）中，以下哪个条件会导致递归的终止？()',
            'A.遍历到未访问过的叶子节点',
            'B.遍历到已访问过的叶子节点',
            'C.遍历到未访问过的非叶子节点',
            'D.遍历到已访问过的非叶子节点',2,
            '在深度优先搜索（DFS）中，当遍历到已访问过的叶子节点时，递归会终止。已访问过的叶子节点是搜索的结束点。'),

            ('以下哪个算法可以用于计算有向无环图（DAG）的拓扑排序？()',
            'A.深度优先搜索（DFS）',
            'B. 广度优先搜索（BFS）',
            'C.迪杰斯特拉算法',
            'D.克鲁斯卡尔算法',2,
            '广度优先搜索（BFS）可以用于计算有向无环图（DAG）的拓扑排序。'),

            ('在广度优先搜索（BFS）过程中，每个节点的访问顺序与以下哪项相关？()',
            'A.节点在图中的位置',
            'B.节点的入度',
            'C.节点的出度',
            'D. 节点的权重',2,
            '在广度优先搜索（BFS）过程中，节点的访问顺序与其入度有关。'),

            ('以下哪个算法可以计算图中两个节点之间的所有路径？()',
            'A.迪杰斯特拉算法',
            'B.克鲁斯卡尔算法',
            'C.深度优先搜索（DFS）',
            'D.广度优先搜索（BFS）',3,
            '深度优先搜索（DFS）可以用于计算图中两个节点之间的所有路径。'),

            ('以下哪个算法可以用于寻找图中的最小生成树？()',
            'A.迪杰斯特拉算法',
            'B.克鲁斯卡尔算法',
            'C.深度优先搜索（DFS）',
            'D.广度优先搜索（BFS）',2,
            ' 说'),

            ('在深度优先搜索（DFS）过程中，以下哪个数据结构被使用来保存遍历顺序？()',
            'A.栈',
            'B.队列',
            'C.数组',
            'D.堆',31,
            ' 说'),

            ('对于一个加权图，以下哪种算法可以计算两个节点之间的最短路径？()',
            'A.迪杰斯特拉算法',
            'B.克鲁斯卡尔算法',
            'C.深度优先搜索（DFS）',
            'D.广度优先搜索（BFS）',1,
            '迪杰斯特拉算法可以用于计算加权图中两个节点之间的最短路径。');



insert into PK(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('Prim算法是一种解决什么问题的算法？()',
            'A.最小生成树问题',
            'B.最短路径问题',
            'C.最大流问题',
            'D.最大匹配问题',1,
            '解析: Prim算法用于寻找一个连通加权图的最小生成树，即在图中选择一些边构成一棵树，使得树上所有边的权值之和最小。'),

            ('Kruskal算法是一种解决什么问题的算法？()',
            'A.最小生成树问题',
            'B.最短路径问题',
            'C.最大流问题',
            'D.最大匹配问题',1,
            '解析: Kruskal算法也用于寻找一个连通加权图的最小生成树，它通过不断选择权值最小的边，并保证边不形成环，直到选出n-1条边为止。'),

            ('Prim算法是以什么方式逐步构建最小生成树？()',
            'A.从源节点开始，逐步添加周围的节点',
            'B.从权值最小的边开始，逐步添加相邻的边',
            'C. 从终点节点开始，逐步添加前驱节点',
            'D.从任意节点开始，随机添加相邻的节点',2,
            'Prim算法从图中任意选择一个节点开始，然后逐步添加权值最小的边，并将新加入的节点作为候选节点，直到所有节点都被包含在最小生成树中。'),

            ('Kruskal算法是以什么方式逐步构建最小生成树？()',
            'A.从源节点开始，逐步添加周围的节点',
            'B.从权值最小的边开始，逐步添加相邻的边',
            'C. 从终点节点开始，逐步添加前驱节点',
            'D.从任意节点开始，随机添加相邻的节点',2,
            '解析: Kruskal算法首先将图中的边按照权值从小到大排序，然后从权值最小的边开始逐步添加，保证边不形成环，直到选出n-1条边为止。'),

            ('Prim算法的时间复杂度是多少？()',
            'A.O(V^2)',
            'B.O(E^2)',
            'C.O(VlogV)',
            'D.O(ElogE)',3,
            ' 0'),

            ('Kruskal算法的时间复杂度是多少？()',
            'A.O(V^2)',
            'B.O(E^2)',
            'C.O(VlogV)',
            'D. O(ElogE)',3,
            '0'),

            ('Prim算法适用于什么类型的图？()',
            'A.有向图',
            'B.无向图',
            'C.加权有向图',
            'D.加权无向图',4,
            '解析: Prim算法适用于解决加权无向图的最小生成树问题，其中图中的边具有权值。'),

            ('Kruskal算法适用于什么类型的图？()',
            'A.有向图',
            'B.无向图',
            'C.加权有向图',
            'D.加权无向图',4,
            '解析: Kruskal算法适用于解决加权无向图的最小生成树问题，其中图中的边具有权值。'),

            ('Prim算法和Kruskal算法都可以用于解决什么问题？()',
            'A.最小生成树问题',
            'B.最短路径问题',
            'C.最大流问题',
            'D.最大匹配问题',1,
            '解析: Prim算法和Kruskal算法都是用于解决最小生成树问题，寻找一个连通加权图的最小生成树。'),

            ('Prim算法在实现过程中需要使用哪种数据结构？()',
            'A.邻接矩阵',
            'B.邻接表',
            'C.堆',
            'D.栈',3,
            '解析: Prim算法的实现过程中需要使用堆这种数据结构，用于选择权值最小的边。'),

            ('Kruskal算法在实现过程中需要使用哪种数据结构？()',
            'A.邻接矩阵',
            'B.邻接表',
            'C.堆',
            'D.并查集',3,
            '解析: Kruskal算法的实现过程中需要使用并查集这种数据结构，用于判断边是否形成环。'),

            ('Prim算法和Kruskal算法的空间复杂度是多少？()',
            'A.O(V)',
            'B.O(E)',
            'C.O(V+E)',
            'D.我不到啊',3,
            '解析: Prim算法和Kruskal算法的空间复杂度都与顶点数V和边数E有关，通常为O(V+E)，取决于具体实现方式。'),

            ('Prim算法和Kruskal算法在什么情况下效率高？()',
            'A.当顶点数很大而边数很小的图',
            'B. 当边数很大而顶点数很小的图',
            'C.当顶点数和边数都很大的图',
            'D.当顶点数和边数都很小的图',2,
            '解析: Prim算法和Kruskal算法在边数很大而顶点数很小的图中效率较高，因为它们的时间复杂度与边数有关。'),

            ('在Prim算法中，如何选择下一个顶点加入最小生成树？()',
            'A.随机选择一个未加入的顶点',
            'B.选择与当前最小生成树距离最近的顶点',
            'C.选择与当前最小生成树连接边权值最小的顶点',
            'D.选择与当前最小生成树连接边权值最大的顶点',3,
            '解析: 在Prim算法中，每次选择与当前最小生成树连接边权值最小的顶点加入最小生成树，以逐步构建最小生成树。'),

            ('在Kruskal算法中，如何判断一条边是否会形成环？()',
            'A.使用并查集数据结构进行判断',
            'B.判断边的两个顶点是否在同一个连通分量中',
            'C.判断边的两个顶点是否相邻',
            'D.我不到啊',2,
            ' 说'),

            ('链栈与顺序栈相比，比较明显的优点是()',
            'A.插入操作更加方便',
            'B.删除操作更加方便',
            'C.入栈时不需要扩容',
            'D.我不到啊',3,
            '入栈时不需要扩容_每次入栈相当于链表中头插一个节点，没有扩容一说');



insert into seqSearch(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('顺序查找的时间复杂度是：()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.O(n^2)',3,
            '解析: 顺序查找需要按顺序遍历整个数组或列表，时间复杂度取决于元素数量n，因此为O(n)。'),

            ('在顺序查找中，最好的情况是()',
            'A.第一个元素就是要查找的元素',
            'B.最后一个元素就是要查找的元素',
            'C.中间某个元素是要查找的元素',
            'D.我不到啊',1,
            '解:如果要查找的元素恰好是第一个元素，那么只需要进行一次比较就能找到，时间复杂度为O(1)。'),

            ('在顺序查找中，最坏的情况是：()',
            'A.第一个元素就是要查找的元素',
            'B.最后一个元素就是要查找的元素',
            'C.中间某个元素是要查找的元素',
            'D.要查找的元素不存在',4,
            '解:如果要查找的元素不存在，则需要遍历整个数组或列表才能确定。时间复杂度为O(n)。'),

            ('在顺序查找中，可以对数组或列表进行哪些操作？()',
            'A.查找',
            'B.插入',
            'C.删除',
            'D.所有选项都可以',4,
            '解:顺序查找只能用于查找元素，不能用于插入或删除元素。'),

            ('当需要反复查找同一个元素时，可以使用哪种数据结构来提高效率？()',
            'A.数组',
            'B.链表',
            'C. 哈希表',
            'D.堆栈',3,
            '解:哈希表可以快速定位元素的位置，因此适合用于反复查找同一个元素的情况。'),

            ('在顺序查找中，查找成功的平均比较次数是多少？()',
            'A.(n+1)/2',
            'B.n/2',
            'C.log(n)',
            'D. n',1,
            '解: 在顺序查找中，要么查找成功，要么查找失败。'),

            ('顺序查找适合于什么样的数据结构？()',
            'A.带有索引的数据结构',
            'B.按一定规律排序的数据结构',
            'C.随机分布的数据结构',
            'D.无限制的数据结构',4,
            '解析: 顺序查找可以应用于任何类型的数据结构，没有任何限制。'),

            ('在顺序查找中，如果要查找的元素在数组的第一项，则最好情况的时间复杂度是多少？()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.O(n^2)',1,
            '解:如果要查找的元素在数组的第一项，则只需要一次比较就能找到，时间复杂度为O(1)。'),

            ('在顺序查找中，如果要查找的元素在数组的最后一项，则最坏情况的时间复杂度是多少？()',
            'A.O(1)',
            'B. O(log n)',
            'C.O(n)',
            'D.O(n^2)',3,
            '解:如果要查找的元素在数组的最后一项，则需要遍历整个数组才能找到，时间复杂度为O(n)。'),

            ('在顺序查找中，如果要查找的元素在数组的中间某个位置，则平均情况的时间复杂度是多少？()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.O(n^2)',3,
            '解:在顺序查找中，要查找的元素可能在任何位置，因此需要遍历整个数组才能确定是否存在，时间复杂度为O(n)。'),

            ('在顺序查找中，如果要查找的元素不止一次出现在数组中，那么查找的结果是什么？()',
            'A.只能找到第一个出现的元素',
            'B.可以找到所有出现的元素',
            'C.找到最后一个元素后就停止查找',
            'D.我不到啊',2,
            '解:顺序查找可以遍历整个数组，找到所有与要查找的元素相等的元素'),

            ('如果使用顺序查找对一个有序数组进行查找，时间复杂度是多少？()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D. O(nlog n)',3,
            '解:如果使用顺序查找对一个有序数组进行查找，则需要遍历整个数组，时间复杂度为O(n)。'),

            ('在顺序查找中，如何判断查找失败？()',
            'A.找到了要查找的元素',
            'B.查找到了数组的最后一项',
            'C.查找过程中出现了错误',
            'D.找到的元素与要查找的元素不相等',2,
            '解:如果要查找的元素在数组中不存在，则需要遍历整个数组才能确定。'),

            ('在顺序查找中，如何判断查找成功？()',
            'A.找到了要查找的元素',
            'B.查找到了数组的最后一项',
            'C.查找过程中出现了错误',
            'D. 找到的元素与要查找的元素不相等',1,
            '解:如果要查找的元素在数组中存在，则会在数组的某个位置找到该元素，此时可以判断查找成功。'),

            ('在顺序查找中，如果要查找的元素存在多次，如何查找第一个元素的位置？()',
            'A.从数组的第一个元素开始查找，直到找到第一个符合条件的元素',
            'B.从数组的最后一个元素开始查找，直到找到第一个符合条件的元素',
            'C.遍历整个数组，记录下所有符合条件的元素的位置',
            'D.我不到啊',1,
            '解: 顺序查找可以遍历整个数组，从第一个元素开始查找，直到找到第一个符合条件的元素。'),

            ('在顺序查找中，如果要查找的元素存在多次，如何查找最后一个元素的位置？()',
            'A.从数组的第一个元素开始查找，直到找到最后一个符合条件的元素',
            'B.从数组的最后一个元素开始查找，直到找到最后一个符合条件的元素',
            'C.遍历整个数组，记录下所有符合条件的元素的位置，然后返回最后一个位置',
            'D.我不到啊',2,
            '解:如果要查找的元素在数组中存在多次，则可以从数组的最后一个元素开始查找，直到找到最后一个符合条件的元素。'),

            ('在顺序查找中，如果要查找的元素存在多次，如何查找所有元素的位置？()',
            'A.从数组的第一个元素开始查找，每找到一个符合条件的元素就保存一下位置',
            'B. 从数组的最后一个元素开始查找，每找到一个符合条件的元素就保存一下位置',
            'C. 遍历整个数组，记录下所有符合条件的元素的位置',
            'D.无法确定所有元素的位置',3,
            '解:如果要查找的元素在数组中存在多次，则可以遍历整个数组，记录下所有符合条件的元素的位置。'),

            ('在顺序查找中，如何查找第k个元素的位置？()',
            'A.遍历整个数组，记录下所有元素的位置，然后返回第k个位置',
            'B.从数组的第一个元素开始查找，每找到一个符合条件的元素就保存一下位置，直到找到第k个元素',
            'C.从数组的最后一个元素开始查找，每找到一个符合条件的元素就保存一下位置，直到找到第k个元素',
            'D.我不到啊',2,
            '解: ');



insert into BST(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('二叉排序树的另一个名称是：()',
            'A.二叉树',
            'B.二叉搜索树',
            'C.平衡二叉树',
            'D.完全二叉树',2,
            '解: '),

            ('对于一个二叉排序树，中序遍历的结果是：()',
            'A.递增序列',
            'B.递减序列',
            'C.随机序列',
            'D.我不到啊',1,
            '解:由于二叉排序树的性质，对其进行中序遍历可以得到一个递增的序列。'),

            ('在二叉排序树中查找一个元素的时间复杂度是：()',
            'A.O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.O(n^2)',2,
            '解:由于二叉排序树的特性，每次查找都可以将搜索范围缩小一半，因此查找一个元素的平均时间复杂度是O(log n)。'),

            ('对于一个有n个节点的二叉排序树，其高度最大为：()',
            'A. n',
            'B.log n',
            'C.n-1',
            'D.n-2',3,
            '解:在最坏情况下，二叉排序树退化成链表，此时高度为n-1。'),

            ('以下哪一种操作可以保证二叉排序树的平衡性：()',
            'A.插入节点时随机选择左右子树',
            'B.每次插入节点后进行平衡调整',
            'C.删除节点时随机选择左右子树',
            'D.以上选项都可以',2,
            '解:通过在插入节点后进行平衡调整操作，可以保证二叉排序树的平衡性，避免出现退化的情况。'),

            ('对于一个二叉排序树，删除节点的操作分为以下几种情况：()',
            'A.只有一种情况',
            'B.两种情况',
            'C.三种情况',
            'D.我不到啊',3,
            '解:删除节点时，可能存在无子节点、有一个子节点、有两个子节点三种情况，需要针对不同情况进行处理。'),

            ('以下哪种操作不会改变二叉排序树的结构：()',
            'A.插入节点',
            'B.删除节点',
            'C.更新节点的值',
            'D.查找节点',4,
            '解:查找节点不会改变二叉排序树的结构，而插入、删除和更新节点的值会改变树的结构。'),

            ('如果一棵二叉树是二叉排序树，则以下哪种说法正确：()',
            'A.中序遍历结果为递减序列',
            'B.前序遍历结果为递减序列',
            'C.后序遍历结果为递减序列',
            'D.以上说法都不正确',4,
            '解:只有中序遍历结果为递增序列，其他遍历方式的结果并不具有递减或递增的特性。'),

            ('对于一棵有n个节点的二叉排序树，最小深度为：()',
            'A.0',
            'B.1',
            'C.logn',
            'D.n',,
            '解:最小深度即为从根节点到最浅叶子节点的路径长度，因此最小深度为1。'),

            ('若二叉排序树中有一个节点的值等于k，则以下哪种说法正确：()',
            'A.左子树上所有节点的值均小于k',
            'B.右子树上所有节点的值均小于k',
            'C.左子树上所有节点的值均大于k',
            'D.右子树上所有节点的值均大于k',3,
            '解:如果二叉排序树中有一个节点的值等于k，则其左子树上所有节点的值均小于k。'),

            ('在二叉排序树中，节点的前驱是指：()',
            'A.比该节点值小的最大节点',
            'B.比该节点值大的最小节点',
            'C.该节点左子树的根节点',
            'D.该节点右子树的根节点',1,
            '解:节点的前驱是指比该节点值小的最大节点，可以通过中序遍历找到节点的前驱。'),

            ('在二叉排序树中，节点的后继是指：()',
            'A.比该节点值小的最大节点',
            'B.比该节点值大的最小节点',
            'C.该节点左子树的根节点',
            'D.该节点右子树的根节点',2,
            '解:节点的后继是指比该节点值大的最小节点，可以通过中序遍历找到节点的后继。'),

            ('二叉排序树的查找操作实际上是在进行什么操作：()',
            'A.顺序查找',
            'B.二分查找',
            'C.插入排序',
            'D.递归查找',2,
            '解:由于二叉排序树的性质，可以通过对比查找值和节点值的大小关系，将搜索范围缩小一半，类似于二分查找的思想。'),

            ('以下哪种情况会导致二叉排序树的不平衡：()',
            'A.插入节点',
            'B.删除节点',
            'C.更新节点的值',
            'D.以上选项都可能导致不平衡',4,
            '解:插入、删除和更新节点的值都有可能导致二叉排序树的不平衡，因此需要进行平衡调整。'),

            ('二叉排序树的最坏情况时间复杂度是：()',
            'A. O(1)',
            'B.O(log n)',
            'C.O(n)',
            'D.O(n^2)',3,
            '解:在最坏情况下，二叉排序树可能退化成链表，此时查找的时间复杂度为O(n)。'),

            ('以下哪种操作可以使得二叉排序树的高度最小：()',
            'A.随机插入节点',
            'B.按照升序插入节点',
            'C.按照降序插入节点',
            'D.以上选项都可以',2,
            '解:按照升序插入节点可以使得二叉排序树的高度最小，退化成链表的可能性最小。'),

            ('二叉排序树的删除操作涉及到的情况有：()',
            'A.只有一种情况',
            'B.两种情况',
            'C.三种情况',
            'D.我不到啊',3,
            '解:删除节点可能存在无子节点、有一个子节点、有两个子节点三种情况，需要针对不同情况进行处理。');
  


insert into OAISort(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('外排序和内排序都是用于处理哪种数据结构？()',
            'A.数组',
            'B.链表',
            'C.栈',
            'D.队列',1,
            '解:外排序和内排序都是用于处理大规模数据存储在数组中的情况。'),

            ('内排序是指：()',
            'A.将数据从内存写入外存前进行排序',
            'B.将数据从外存读入内存后进行排序',
            'C.将数据从外存读入内存并在内存中进行排序',
            'D.将数据从内存写入外存后进行排序',3,
            '解:内排序是指将数据从外存读入内存后，在内存中进行排序操作。'),

            ('外排序是指：()',
            'A.将数据从外存读入内存后进行排序',
            'B.将数据从外存读入内存并在内存中进行排序',
            'C.将数据从内存写入外存后进行排序',
            'D.将数据从内存写入外存前进行排序',3,
            '解:外排序是指将数据从内存写入外存后，在外存中进行排序操作。'),

            ('内排序算法的时间复杂度通常从小到大排列是：()',
            'A. O(1) < O(n) < O(log n) < O(n^2)',
            'B.O(1) < O(log n) < O(n) < O(n^2)',
            'C.O(1) < O(log n) < O(n^2) < O(n)',
            'D.O(1) < O(n) < O(n^2) < O(log n)',2,
            '解:内排序算法的时间复杂度通常按照O(1) < O(log n) < O(n) < O(n^2)的顺序进行排列。'),

            ('外排序算法的时间复杂度通常从小到大排列是：()',
            'A. O(1) < O(n) < O(log n) < O(n^2)',
            'B.O(1) < O(log n) < O(n) < O(n^2)',
            'C.O(1) < O(log n) < O(n^2) < O(n)',
            'D.O(1) < O(n) < O(n^2) < O(log n)',3,
            '解:外排序算法的时间复杂度通常按照O(1) < O(log n) < O(n^2) < O(n)的顺序进行排列。'),

            ('下列哪种排序算法适合对大文件进行外排序？()',
            'A.冒泡排序',
            'B.插入排序',
            'C.快速排序',
            'D.选择排序',3,
            '解:快速排序具有较好的平均时间复杂度和适应性，适合对大文件进行外排序。'),

            ('内排序算法的优势是：()',
            'A.不需要额外的外存空间',
            'B.排序速度快',
            'C.算法简单易实现',
            'D.以上选项都是',4,
            '解: 说'),

            ('内排序中的选择排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D. O(n^2)',2,
            '解:选择排序的时间复杂度为O(n^2)，因为需要进行n次选择，每次选择需要遍历剩余n-i个元素。'),

            ('内排序中的冒泡排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(1)',2,
            '解:冒泡排序的时间复杂度为O(n^2)，因为需要进行n-1次比较和交换操作，每次操作需要遍历剩余元素。'),

            ('内排序中的插入排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(1)',2,
            '解:插入排序的时间复杂度为O(n^2)，因为需要进行n-1次比较和移动操作，每次操作需要遍历已排序的元素。'),

            ('内排序中的希尔排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',4,
            '解:希尔排序的时间复杂度为O(n log n)，由于它采用分组进行插入排序，可以减少比较和移动操作的次数。'),

            ('内排序中的快速排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',4,
            '解:快速排序的时间复杂度为O(n log n)，由于它采用分治和递归的思想，可以将大规模问题分解为小规模问题进行解决。'),

            ('内排序中的归并排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',4,
            '解: '),

            ('外排序中的归并排序时间复杂度是：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',4,
            '解: '),

            ('外排序中的多路归并排序是指：()',
            'A.将数据分成两路进行归并排序',
            'B.将数据分成三路或更多路进行归并排序',
            'C.将数据分成两路进行选择排序',
            'D.将数据分成三路或更多路进行选择排序',2,
            '解:多路归并排序是指将数据分成三路或更多路进行归并排序，以减少每次归并操作中的数据比较次数和移动次数。'),

            ('在外排序中，常用的排序算法不包括：()',
            'A.快速排序',
            'B.归并排序',
            'C.堆排序',
            'D.冒泡排序',4,
            '解:冒泡排序需要对相邻元素进行比较和交换，不适合用于外排序中。'),

            ('在外排序中，常用的外存数据结构包括：()',
            'A.顺串文件',
            'B.链串文件',
            'C.直接存取文件',
            'D.以上选项都是',4,
            '解:常用的外存数据结构包括顺串文件、链串文件和直接存取文件，以满足外排序算法对外存数据的要求。');



insert into Heapsort(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('堆排序是一种()',
            'A.内排序算法',
            'B.外排序算法',
            'C.排序算法中的稳定排序',
            'D.以上选项都不是',1,
            '解:堆排序是一种内排序算法，可以在内存中直接进行排序操作。'),

            ('堆排序的时间复杂度为：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',4,
            '解:堆排序的时间复杂度为O(n log n)，可以保证在大多数情况下的高效性。'),

            ('堆排序的空间复杂度为：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(1)',4,
            '解:堆排序的空间复杂度为O(1)，只需要一个额外的变量用于交换元素即可。'),

            ('堆排序可以使用以下哪种数据结构来实现堆：()',
            'A.数组',
            'B.链表',
            'C.栈',
            'D.以上选项都不是',1,
            '解:堆排序通常使用数组来实现堆结构。'),

            ('堆排序中，堆的构建时间复杂度为：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',1,
            '解:堆的构建时间复杂度为O(n)，即对n个元素进行一次建堆操作。'),

            ('堆排序中，堆的调整时间复杂度为：()',
            'A.O(n)',
            'B.O(n^2)',
            'C.O(log n)',
            'D.O(n log n)',3,
            '解:堆的调整时间复杂度为O(log n)，即每次删除堆顶元素后需要进行一次堆调整操作。'),

            ('堆排序中，堆的调整操作通常包括以下几个步骤：()',
            'A.删除堆顶元素',
            'B.将最后一个元素放到堆顶',
            'C.从堆顶开始向下调整堆',
            'D.以上选项都是',4,
            '解:堆的调整操作通常包括以上三个步骤。'),

            ('堆排序中，堆的调整操作是将较大元素向上调整还是将较小元素向下调整：()',
            'A.将较大元素向上调整',
            'B.将较小元素向下调整',
            'C.可以是将较大元素向上调整，也可以是将较小元素向下调整',
            'D.我不到啊',2,
            '解:堆排序中，堆的调整操作通常是将较小元素向下调整，以保证堆的性质。'),

            ('堆排序中，堆的建立过程是自底向上还是自顶向下：()',
            'A.自底向上',
            'B.可以是自底向上，也可以是自顶向下',
            'C.自顶向下',
            'D.我不到啊',3,
            '解:堆排序中，堆的建立过程通常是自顶向下进行的，先构建小根堆或大根堆，再进行排序。'),

            ('堆排序中，如果要按照从小到大排序，应该使用以下哪种堆：()',
            'A.大根堆',
            'B.小根堆',
            'C.无法确定',
            'D.以上选项都不是',2,
            '解:如果要按照从小到大排序，应该使用小根堆，因为小根堆的堆顶元素最小。'),

            ('堆排序中，如果要按照从大到小排序，应该使用以下哪种堆：()',
            'A.大根堆',
            'B.小根堆',
            'C.无法确定',
            'D.以上选项都不是',1,
            '解:如果要按照从大到小排序，应该使用大根堆，因为大根堆的堆顶元素最大。'),

            ('堆排序中，堆排序算法的稳定性如何：()',
            'A.稳定',
            'B.不稳定',
            'C.可能稳定，也可能不稳定',
            'D.以上选项都不是',2,
            '解:堆排序算法是不稳定排序算法，可能会改变相同元素之间的相对顺序。'),

            ('堆排序中，堆排序算法的原地性如何：()',
            'A.原地排序',
            'B.非原地排序',
            'C. 可能原地排序，也可能非原地排序',
            'D.以上选项都不是',1,
            '解:堆排序算法是原地排序算法，只需要一个额外的变量用于交换元素即可'),

            ('链栈与顺序栈相比，比较明显的优点是()',
            'A.插入操作更加方便',
            'B.删除操作更加方便',
            'C.入栈时不需要扩容',
            'D.我不到啊',3,
            '解:入栈时不需要扩容_每次入栈相当于链表中头插一个节点，没有扩容一说'),

            ('堆排序中，如果要从一个已经排好序的数组中添加一个新元素并重新排序，应该使用以下哪种方法()',
            'A.删除堆顶元素，再将新元素插入堆中',
            'B.将新元素插入堆中，再调整堆',
            'C.对整个数组进行堆排序',
            'D.以上选项都有可能',2,
            '解:如果要从一个已经排好序的数组中添加一个新元素并重新排序，应该将新元素插入堆中，再调整堆。'),

            ('堆排序中，堆的性质是什么：()',
            'A.父节点的值小于等于左右子节点的值',
            'B.父节点的值大于等于左右子节点的值',
            'C.父节点的值小于左右子节点的值',
            'D.父节点的值大于左右子节点的值',2,
            '解:堆的性质是父节点的值大于等于左右子节点的值，在小根堆中，父节点的值比子节点的值小，在大根堆中，父节点的值比子节点的值大。'),

            ('在堆排序过程中，通过交换堆顶元素和最后一个元素，可以实现：()',
            'A.删除堆顶元素',
            'B.插入最后一个元素',
            'C.对堆进行调整',
            'D.以上选项都是',4,
            '解:通过交换堆顶元素和最后一个元素，可以删除堆顶元素，插入最后一个元素，并对堆进行调整。'),

            ('在堆排序算法中，堆的首个元素索引为：()',
            'A. 0',
            'B.1',
            'C.可以是0或1，取决于实现方式',
            'D.以上选项都不是',3,
            '解:在堆排序算法中，通常使用从1开始的索引来表示堆中的元素。');



insert into Quicksort(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('快速排序算法的时间复杂度是：()',
            'A.O(n)',
            'B.O(nlogn)',
            'C.O(n^2)',
            'D.O(logn)',2,
            '解:快速排序算法的平均时间复杂度是O(nlogn)。'),

            ('快速排序算法的空间复杂度是：()',
            'A. O(1)',
            'B.O(n)',
            'C.O(logn)',
            'D.O(nlogn)',3,
            '解:快速排序算法的空间复杂度是O(logn)，因为需要考虑递归调用的栈空间。'),

            ('快速排序算法的思想是：()',
            'A. 分治法',
            'B. 动态规划',
            'C.贪心算法',
            'D.回溯算法',1,
            '解:快速排序算法的核心思想是使用分治法。'),

            ('快速排序算法在最坏情况下的时间复杂度是：()',
            'A.随机化选取基准元素',
            'B.三数取中选取基准元素',
            'C.插入排序优化',
            'D.全部正确性判断',4,
            '解:以上三种方法都是快速排序算法的优化手段。'),

            ('快速排序算法在处理重复元素时可能会出现的问题是：()',
            'A.内存泄漏',
            'B.栈溢出',
            'C.死循环',
            'D.不稳定',3,
            '解:处理重复元素时可能会导致死循环。'),

            ('在快速排序算法中，当左右指针相遇时，应该：()',
            'A.直接返回',
            'B.将基准元素与左指针所指元素交换',
            'C.将基准元素与右指针所指元素交换',
            'D.将基准元素与中间位置元素交换',3,
            '解:当左右指针相遇时，应该将基准元素与右指针所指元素交换。'),

            ('快速排序算法在选择基准元素时，经常使用的方法是：()',
            'A.选取第一个元素作为基准元素',
            'B.选取最后一个元素作为基准元素',
            'C.随机选取一个元素作为基准元素',
            'D.选取中间位置的元素作为基准元素',3,
            '解:随机选取基准元素可以避免最坏情况的发生。'),

            ('在实际应用中，快速排序算法的时间复杂度通常比归并排序算法更低，原因是：()',
            'A.快排比归并排序更容易实现',
            'B.快排比归并排序占用的内存更少',
            'C.快排比归并排序更适合处理大规模数据',
            'D.快排和归并排序的时间复杂度是相同的',3,
            '解:快速排序算法通常更适合处理大规模数据，因为它可以原地排序，不需要额外的内存空间。'),

            ('快速排序算法的平均时间复杂度是多少？()',
            'A.O(n)',
            'B.O(nlogn)',
            'C.O(n^2)',
            'D.O(logn)',2,
            '解:快速排序算法的平均时间复杂度是O(nlogn)'),

            ('下面哪种情况下快速排序算法的效率最高？()',
            'A.数组已经排好序',
            'B.数组元素全部相同',
            'C.数组元素随机分布',
            'D.数组元素呈现周期性分布',3,
            '解:当数组元素随机分布时，快速排序算法的效率最高。'),

            ('快速排序算法的最坏时间复杂度是多少？()',
            'A. O(n)',
            'B.O(nlogn)',
            'C.O(n^2)',
            'D.O(logn)',3,
            '解:快速排序算法的最坏时间复杂度是O(n^2)，发生在待排序数组已经有序或者近似有序的情况下。'),

            ('在快速排序算法中，如何避免出现最坏情况？()',
            'A.增加栈深度',
            'B.使用随机化选取基准元素的方法',
            'C.使用插入排序优化',
            'D.使用归并排序代替快速排序',2,
            '解:使用随机化选取基准元素的方法可以避免出现最坏情况。'),

            ('快排的思想是？()',
            'A.选择排序',
            'B.插入排序',
            'C.快速排序',
            'D.归并排序',3,
            '解:快速排序算法的核心思想是分治法。'),

            ('快速排序算法的应用场景是？()',
            'A.排序',
            'B.查找',
            'C.遍历',
            'D.计数',1,
            '解:快速排序算法主要用于排序场景，可以对大规模数据进行高效排序。'),

            ('快速排序算法的空间复杂度与数据是否有序有关吗？()',
            'A. 有关',
            'B.不关',
            'C.j',
            'D.我不到啊',1,
            '解:快速排序算法的空间复杂度与待排序数据的有序程度有关系，当待排序数组近似有序时，空间复杂度会增加。'),

            ('快速排序算法的稳定性与其实现方式有关吗？()',
            'A.有关',
            'B.不关',
            'C.j',
            'D.我不到啊',2,
            '解:快速排序算法是一种不稳定的排序算法，与实现方式无关。'),

            ('快速排序算法的实现是否具有可读性？()',
            'A. 具有可读性',
            'B.不具有可读性',
            'C.j',
            'D.我不到啊',2,
            '解:快速排序算法的实现相对较为复杂，不太容易理解。'),

            ('快速排序算法的稳定性是：()',
            'A.稳定',
            'B.j',
            'C.不稳定',
            'D.我不到啊',3,
            '解:快速排序算法是一种不稳定的排序算法。');



insert into Mergesort(content,option_A,option_B,option_C,option_D,correct_ot,explanation) values
            ('归并排序算法的时间复杂度是：()',
            'A.O(n)',
            'B.O(nlogn)',
            'C.O(n^2)',
            'D.O(logn)',2,
            '解:归并排序算法的时间复杂度是O(nlogn)。'),

            ('归并排序算法的空间复杂度是：()',
            'A.O(1)',
            'B.O(n)',
            'C.O(logn)',
            'D.O(nlogn)',4,
            '解:入栈时不需要扩容_每次入栈相当于链表中头插一个节点，没有扩容一说'),

            ('归并排序算法的稳定性是：()',
            'A.稳定',
            'B.不稳定',
            'C.j',
            'D.我不到啊',1,
            '解:归并排序算法是一种稳定的排序算法。'),

            ('归并排序算法的思想是：()',
            'A.分治法',
            'B.动态规划',
            'C.贪心算法',
            'D.回溯算法',1,
            '解:归并排序算法的核心思想是使用分治法。'),

            ('归并排序算法在最坏情况下的时间复杂度是：()',
            'A. O(n)',
            'B.O(nlogn)',
            'C. O(n^2)',
            'D.O(logn)',2,
            '解:入栈时不需要扩容_每次入栈相当于链表中头插一个节点，没有扩容一说'),

            ('归并排序算法的优化方法有：()',
            'A.自底向上排序',
            'B.二路归并排序',
            'C.三路归并排序',
            'D.以上全部',4,
            '解: '),

            ('归并排序算法在处理重复元素时是否会出现问题？()',
            'A.会',
            'B.j',
            'C.不会',
            'D.我不到啊',3,
            '解:归并排序算法处理重复元素时不会出现问题。'),

            ('在归并排序算法中，如何避免出现最坏情况？()',
            'A.增加栈深度',
            'B.使用随机化选取基准元素的方法',
            'C.使用插入排序优化',
            'D.将递归转化为迭代',4,
            '解:将递归转化为迭代可以避免出现最坏情况。'),

            ('归并排序算法的实现是否具有可读性？()',
            'A.不具有可读性',
            'B.具有可读性',
            'C.入栈时不需要扩容',
            'D.我不到啊',1,
            '解:归并排序算法的实现相对较为简单，容易理解。'),

            ('归并排序算法需要使用递归吗？()',
            'A.需要',
            'B.j',
            'C.不需要',
            'D.我不到啊',1,
            '解:归并排序算法是一种分治算法，需要使用递归实现。'),

            ('归并排序算法的平均时间复杂度是多少？()',
            'A.O(n)',
            'B.O(nlogn)',
            'C. O(n^2)',
            'D.O(logn)',2,
            '解:归并排序算法的平均时间复杂度也是O(nlogn)。'),

            ('下面哪种情况下归并排序算法的效率最高？()',
            'A.数组已经排好序',
            'B.数组元素全部相同',
            'C.数组元素随机分布',
            'D.数组元素呈现周期性分布',3,
            '解:当数组元素随机分布时，归并排序算法的效率最高。'),

            ('归并排序算法的最坏时间复杂度是多少？()',
            'A.O(n)',
            'B.O(nlogn)',
            'C.O(n^2)',
            'D.O(logn)',2,
            '解:归并排序算法的最坏时间复杂度也是O(nlogn)。'),

            ('在归并排序算法中，如何实现自底向上排序？()',
            'A.使用递归实现',
            'B. 使用循环实现',
            'C.使用栈实现',
            'D.使用队列实现',2,
            '解:使用循环可以实现自底向上排序。'),

            ('归并排序算法的稳定性与其实现方式有关吗？()',
            'A.j',
            'B.有关',
            'C.不关',
            'D.我不到啊',3,
            '解:归并排序算法是一种稳定的排序算法，与实现方式无关。'),

            ('归并排序算法的应用场景是？()',
            'A.查找',
            'B.遍历',
            'C. 排序',
            'D.计数',3,
            '解:归并排序算法主要用于排序场景，可以对大规模数据进行高效排序。'),

            ('归并排序算法的核心操作是什么？()',
            'A.比较',
            'B.交换',
            'C.分割',
            'D.合并',4,
            '解:归并排序的核心操作是合并，将两个有序子序列合并成一个有序序列。'),

            ('归并排序算法的稳定性是指什么？()',
            'A.排序结果是否与初始顺序一致',
            'B.排序过程中是否会出现死循环',
            'C.排序算法是否具有递归结构',
            'D.排序算法是否需要额外的空间',1,
            '解:归并排序的稳定性指排序结果是否与初始顺序一致，即相同元素的相对位置是否保持不变。'),

            ('归并排序算法在哪个步骤进行数据的合并操作？()',
            'A.分割步骤',
            'B.比较步骤',
            'C.交换步骤',
            'D.合并步骤',4,
            '解:归并排序在合并步骤中进行数据的合并操作。'),

            ('归并排序算法的最佳时间复杂度是多少？()',
            'A.O(n)',
            'B.O(nlogn)',
            'C. O(n^2)',
            'D.O(logn)',2,
            '解:归并排序的最佳时间复杂度是O(nlogn)，在任何情况下都能达到该复杂度。');
     


insert into timutimu(content,option_A,option_B,option_C,option_D,correct_ot,explanation,
            Search_Algorithm,sorting_algorithm,Link_List,queue,stack,array,tree,graph) values
            ('对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是()',
            'A. head==NULL',
            'B. head.next==NULL',
            'C. head.next==head',
            'D. head!=NULL',2,
            'B. head.next==NULL是判定该带头结点的单链表为空表的条件，因为在带头结点的单链表中，head指向的是头结点，而头结点的next指针一个元素结点，如果表中没有元素结点，那么头结点的next指针就应该为NULL',
            0,0,1,0,0,0,0,0),

            ('在双向循环链表中,在p指针所指向的结点前插入一个指针q所指向的新结点,其修改指针的操作是( )',
            'A. p.llink=q； q.rlink=p； p.llink.rlink=q； q.llink=q',
            'B. p.llink=q； p.llink.rlink=q； q.rlink= p； q.llink=p.llink',
            'C. q.rlink=p； q.llink=p.llink； p.llink.rlink=q；  p.llink=q',
            'D. q.llink=p.llink；q.rlink:=p； p.llink=q； p↑.llink=q',3,
            '选项C是正确的操作顺序。其他选项中，有些是缺少指针修改，有些则是指针修改顺序错误',
            0,0,1,0,0,0,0,0),

            ('一个栈的输入序列为1、2、3、4、5，则下列序列中不可能是栈的输出序列的是',
            'A. 2、3、4、1、5',
            'B. 5、4、2、3、1',
            'C. 2、3、1、4、5',
            'D. 1、5、4、3、2',2,
            '选项B中的输出序列得到的逆序输入序列为5、4、2、3、1，与原输入序列不一致。因此，选项B中的序列不可能是栈的输出序列。',
            0,0,0,0,1,0,0,0),

            ('循环队列A[0..m-1]存放其元素值，用front和rear分别表示队头和队尾，则当前队列中的元素数是( )',
            'A. (rear-front+m)%m',
            'B. rear-front+1',
            'C. rear-front-1',
            'D. rear-front',1,
            '在循环队列中，队尾指针rear始终指向队列中最后一个元素的下一个位置，队头指针front指向队列中第一个元素的位置。一种常用的计算公式是：(rear-front+m)%m，其中m为队列的最大长度，%为取模运算符。',
            0,0,0,1,1,0,0,0),

            ('设二维数组a[1..5][1..8]，若按列优先的顺序存放数组的元素，则a[4][6]元素的前面（ ）个元素。',
            'A. 6',
            'B. 28',
            'C. 29',
            'D. 40',3,
            '要求a[4][6]元素前面的元素个数，可以计算它在一维数组中的下标，即(6-1)*5+4=29。',
            0,0,0,0,0,1,0,0),

            ('设栈S和队列Q的初始状态为空，元素e1，e2，e3，e4,e5和e6依次通过栈S，一个元素出栈后即进队列Q，若6个元素出队的序列是e2，e4，e3,e6,e5,e1则栈S的容量至少应该是( )。',
            'A. 6',
            'B. 4',
            'C. 3',
            'D. 2',4,
            '根据进栈的顺序，可以得到栈S的初始状态为e1，e2，e3，e4，e5，e6。根据栈的特性，先进后出，因此最后出栈的是e2，因此栈的容量至少应该是2，因此答案为D. 2。',
            0,0,0,1,0,0,0,0),

            ('若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为多少？( )',
            'A. 1和 5',
            'B. 2和4',
            'C. 4和2',
            'D. 5和1',2,
            '由于数组的大小为6，当rear指向数组的最后一个元素时，需要将其指向数组的第一个元素，因此rear的最终值为2%6=2。因此，删除一个元素并加入两个元素后，rear和front的值分别为2和4。',
            0,0,1,0,0,0,0,0),

            ('高度为h（h>0）的满二叉树对应的森林由（ ） 棵树构成',
            'A. 1',
            'B. log2h',
            'C. h/2',
            'D. h',4,
            '高度为h的满二叉树中，所有叶子结点的层次均为h，其根结点及其左下结点共有h个，所以还原成森林含有h棵树',
            0,0,0,0,0,0,1,0),

            ('设有一棵哈夫曼树的结点总数为35，则该哈夫曼树共有 （ ）个叶子结点',
            'A. 18',
            'B. 20',
            'C. 35',
            'D. 30',1,
            '2n-1 = 35, n=18',
            0,0,0,0,0,0,1,0),

            ('一棵具有 n个结点的完全二叉树的树高度（深度）是（ ）',
            'A. |logn|+1',
            'B. logn+1',
            'C. |logn|',
            'D. logn-1',1,
            '对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同,且叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部。深度为k的完全二叉树在k-1层上一定是满二叉树。即答案为A。',
            0,0,0,0,0,0,1,0),

            ('二叉树的先序遍历和中序遍历如下： 先序遍历：EFHIGJK；中序遍历: HFIEJKG 。该二叉树根的右子树的根是：',
            'E',
            'F',
            'G',
            'H',3,
            '由于先序遍历序列的第一个元素是根节点，因此，该二叉树的根节点是E。需要找到E的右子树的根节点。根据中序遍历序列，E的左边是HF，右边是IJKG，因此E的右子树的根节点一定在先序遍历序列EFHIGJK的HIGJK中。H是E的左孩子，因此H不可能是E的右子树的根节点。因此，需要继续查找。在剩余的IJKG中，I是H的右兄弟，因此I也不可能是E的右子树的根节点。在剩余的JKG中，K是I的左孩子，因此K也不可能是E的右子树的根节点。G是K的右兄弟，因此G可能是E的右子树的根节点。如果G是E的右子树的根节点，则E的右子树的先序遍历序列为GHJK，中序遍历序列为JKG。根据这两个序列，可以构造出E的右子树，得到答案为C。',
            0,0,0,0,0,0,1,0),

            ('某二叉树中序序列为A,B,C,D,E,F,G，后序序列为B,D,C,A,F,G,E 则前序序列是：',
            'E,G,F,A,C,D,B',
            'E,A,C,B,D,G,F',
            'E,A,G,C,F,B,D',
            '上面的都不对',4,
            '从后序序列中可以得到根节点为E。然后，在中序序列中找到根节点E的位置，将中序序列分为左子树A,B,C,D和右子树F,G，同时可以得到后序序列中左子树的序列为B,D,C，右子树的序列为F,G。对于左子树，它的根节点为B，可以通过后序序列得到它的左子树为D，右子树为C，因此，左子树的前序序列为B,D,C。对于右子树，它的根节点为F，可以通过后序序列得到它的左子树为G，右子树为空，因此，右子树的前序序列为F,G。综上所述，该二叉树的前序序列为E,B,D,C,F,G,A。',
            0,0,0,0,0,0,1,0),

            ('设有向图n个顶点和e条边，进行拓补排序时，总的计算时间为',
            'A. O<nlog(2)e>',
            'B. O<e*n>',
            'C. O<elog(2)n>',
            'D. O<n+e>',4,
            '拓补排序：对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序的序列，简称拓扑序列。',
            1,1,0,0,0,0,0,1),

            ('关键路径是事件结点网络中',
            'A. 从源点到汇点的最长路径',
            'B. 从源点到汇点的最短路径',
            'C. 最长的回路',
            'D. 最短的回路',1,
            '关键路径是是从源点到汇点的最长路径的长度。',
            1,0,0,0,0,0,0,1),

            ('有10个结点的无向图至少有（）条边才能确保其是连通图',
            'A. 8',
            'B. 9',
            'C. 10',
            'D. 11',2,
            '在一个无向图G中，若从顶点vi到顶点vj有路径相连(当然从vj到vi也一定有路径)，则称vi和vj是连通的。如果G是有向图，那么连接vi和vj的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。',
            1,0,0,0,0,0,0,1),

            ('最短路径的生成算法可用',
            'A. 普利姆算法',
            'B. 克鲁斯卡尔算法',
            'C. 迪杰斯特拉算法',
            'D. 哈夫曼算法',3,
            '迪杰斯特拉算法基本原理：从起始点出发，重复寻找当前距离起始点最近的且未访问过的结点，然后利用该结点更新距离数组，直到访问过全部结点为止，最终的距离数组即为起始点到其余各点的最短路径距离。',
            1,0,0,0,0,0,0,1),

            ('n条边的无向图的邻接表的存储中，边结点的个数有',
            'A. n',
            'B. 2n',
            'C. n/2',
            'D. n*n',1,
            'n条边->n个结点。',
            1,0,0,0,0,0,0,1),

            ('下列哪一种图的邻接矩阵是对称矩阵',
            'A. 有向图',
            'B. 无向图',
            'C. AOV网',
            'D. AOE网',2,
            '只有无向图的邻接矩阵是对称矩阵。',
            1,0,0,0,0,0,0,1),

            ('如果一个表既能较快地查找，又能适应动态变化的要求，则可采用( ) 。',
            'A. 有序表',
            'B. 线性表',
            'C. 哈希表',
            'D. 二叉平衡树',4,
            '在二叉平衡树中进行插入或删除操作时，会通过旋转操作来调整树的结构，以使得树的左右子树的高度差不超过1。这样可以保证树的高度始终保持在一个较小的范围内，从而保证了查找、插入和删除操作的时间复杂度都能够达到O(log n)的水平。此外，二叉平衡树还能够适应动态变化的要求，因为它可以通过旋转操作来动态调整树的结构，以适应不断变化的数据集合。当我们在二叉平衡树中插入或删除一个节点时，只需要通过一系列的旋转操作来调整树的结构，就可以保持树的平衡性，从而保证了整个树的性能。',
            1,0,1,0,0,1,1,0),

            ('在含有n个结点的二叉排序树中查找某关键字的结点时，最多进行（）次比较。',
            'A. n/2',
            'B. log2n',
            'C. log2n+1',
            'D. n',4,
            '在一个含有n个结点的二叉排序树中，最长的路径长度为n，因此，在最坏情况下，需要进行n次比较才能找到目标结点。',
            1,0,0,0,0,0,1,0),

            ('以下关于哈希查找的叙述中错误的是（ ）。',
            'A. 用拉链法解决冲突易引起堆积现象',
            'B. 用线性探测法解决冲突易引起堆积现象',
            'C. 哈希函数选得好可以减少冲突现象',
            'D. 哈希函数H(k)=k MOD p，p通常取小于等于表长的素数',1,
            '当哈希表中存在大量元素时，拉链法的性能可能会急剧下降，因为在遍历链表时需要花费更长的时间来找到匹配的元素。这也会导致哈希表的负载因子变得非常高，这会进一步增加哈希冲突的概率，从而导致更多的堆积现象，最终导致哈希表的性能崩溃',
            1,0,0,0,0,0,0,0),

            ('在平衡二叉树中插入一个结点后造成了不平衡，设最低的不平衡结点为A,并已知A的左孩子的平衡因子为0右孩子的平衡因子为1,则应作( ) 型调整以使其平衡。',
            'A. LL',
            'B. LR',
            'C. RL',
            'D. RR',3,
            '如果使用LL型或RR型调整，将会使得A的左子树或右子树高度更大，而B的高度较小，无法维持平衡。而使用LR型或RL型调整，则可以将A的左右子树高度差不超过1，并且可以保持B的子树结构不变，避免了更多的旋转操作。',
            1,0,0,0,0,0,1,0),

            ('具有12个关键字的有序表，折半查找的平均查找长度（）不是：0.5*成功 + 0.5*失败？',
            'A. 3.1',
            'B. 4',
            'C. 2.5',
            'D. 5',1,
            '折半查找的平均查找长度是根据关键字在有序表中出现的概率分布来计算的。因此，不能简单地将平均查找长度简单地分为成功和失败两个情况。折半查找的平均查找长度为 $log_2(n+1)-1$，其中 $n$ 是有序表中元素的个数。在具有12个关键字的有序表中，$n=12$，因此平均查找长度为 $log_2(13)-1 approx 3.1$。这个公式不考虑查找成功和失败的情况，而是基于有序表中元素的数量来计算平均查找长度。因此，无论查找成功还是失败，平均查找长度都是一样的。',
            1,0,0,0,0,0,0,0),

            ('设哈希表长为14，哈希函数是H(key)=key%11,表中已有数据的关键字地址为：为address(15)=4，address(38)=5，address(61)=6，address(84)=7共四个，现要将关键字为49的结点加到表中，用二次探测再散列法解决冲突，则放入的位置是() ',
            'A. 8',
            'B. 3',
            'C. 5',
            'D. 9',4,
            '根据哈希函数 H(key) = key % 11，可以计算出关键字为 49 的地址为：H(49) = 49 % 11 = 5由于这个地址已经被关键字为 38 的结点占用了，因此需要解决哈希冲突。题目中要求使用二次探测再散列法解决冲突，因此可以使用以下公式来计算下一个探测地址：di = i^2，其中i = 1, 2, 3, ...也就是说，第一次探测地址为 5，第二次探测地址为 6，第三次探测地址为 9，因为：d1 = 1^2 = 1，H(49) + d1 = 5 + 1 = 6d2 = 2^2 = 4，H(49) + d2 = 5 + 4 = 9 因此，关键字为 49 的结点应该插入到地址为 9 的位置上。',
            1,0,1,0,0,1,0,0),

            (' 以下 （ ）方法在数据基本有序时效率最好',
            'A.快速排序',
            'B. 冒泡排序',
            'C. 堆排序',
            'D. 希尔排序',4,
            '当数据基本有序时，希尔排序通过将相距一定间隔的元素分为一组，然后对每组进行插入排序。由于每组元素的距离较远，因此在排序时可以一次移动较多元素的位置，从而加快排序的速度。随着排序的进行，希尔排序会不断缩小元素之间的间隔，直到元素之间的间隔为1，此时就变成了普通的插入排序。在这种情况下，由于元素之间的间隔已经很小了，因此插入排序的效率也会非常高。',
            0,1,1,0,0,0,0,0),

            ('归并排序中，归并的趟数是( )。',
            'A. O（n）',
            'B. O(log₂n)',
            'C. O(nlogn)',
            'D. O(n*n)',2,
            '归并排序的核心思想是将待排序元素分成若干个子序列，然后对每个子序列进行排序，最后再将已排序的子序列合并成一个完整的有序序列。在归并排序的每一轮合并中，都会将相邻的两个子序列合并成一个更大的有序序列。因此，每轮合并都会使序列的长度翻倍。假设序列中有n个元素，每轮合并后序列长度翻倍，那么需要进行log₂n轮合并才能使序列中的所有元素有序。因此，归并排序的归并趟数是log₂n',
            0,1,0,0,0,0,0,0),

            ('下列四个序列中，哪一个是堆（ ）',
            'A. 75,65,30,15,25,45,20,10',
            'B. 75,65,45,10,30,25,20,15',
            'C. 75,45,65,30,15,25,20,10',
            'D. 75,45,65,10,25,30,20,15',2,
            '在这四个序列中，只有选项 B 是堆序列。因为选项 B 中的每个父节点的键值都大于或等于其子节点的键值。例如，节点 75 是其子节点 65 和 45 的父节点，而节点 75 的键值大于其子节点的键值，同样节点 65 和 45 也满足这个条件。因此，选项 B 是堆序列。而在选项 A、C、D 中，存在至少一个父节点的键值小于其子节点的键值，因此它们不是堆序列。',
            0,1,0,0,1,1,0,0),

            ('对序列{15，9，7，8，20，-1，4，} 用希尔排序方法排序，经一趟后序列变为{15，-l，4，8，20，9，7}则该次采用的增量是 ( )',
            'A. 1',
            'B. 4',
            'C. 3',
            'D. 2',2,
            '希尔排序是一种基于插入排序的排序算法，它通过将原始序列分割成若干个子序列来进行排序，逐步缩小子序列的长度，最终将整个序列排序。在希尔排序中，增量序列是关键。增量序列可以是任何数列，但通常使用以下序列：1、4、13、40、121、364、1093、……（也就是h = 3*h + 1，h为当前增量）。其中最后一个增量值必须小于等于序列长度的三分之一。根据题目描述，经过一趟希尔排序后，序列变为 {15，-1，4，8，20，9，7}。因此，我们可以猜测此次采用的增量是4，即按照4-3-1的增量序列进行排序。验证：按照增量为4的希尔排序方法，原序列可以分为两个子序列：{15，20，4，}和{9，-1，7，8}，分别进行插入排序后变为{4，15，20，}和{-1，7，8，9}，然后合并两个子序列得到{4，15，20，-1，7，8，9}，再次进行一趟增量为4的希尔排序后得到{15，-1，4，8，20，9，7}，与题目描述的一致。因此，该次采用的增量为4。',
            0,1,1,0,0,0,0,0),

            (' 一组记录的关键码为（46，79，56，38，40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（ ）',
            'A. (38,40,46,56,79,84）',
            'B. (40,38,46,79,56,84)',
            'C. (40,38,46,56,79,84)',
            'D. (40,38,46,84,56,79)',1,
            '利用快速排序的方法，以第一个记录46为基准进行划分，将比46小的记录放到左边，比46大的记录放到右边，得到以下结果：(38, 40, 56, 46, 79, 84)此时基准记录46已经被放到了不正确的位置上，接下来需要对左右两个子序列分别进行快速排序，直到所有子序列的长度都为1或0。对左边的子序列(38, 40, 56)进行快速排序，以第一个记录38为基准进行划分，得到以下结果：(38, 40, 56)此时左边的子序列已经有序，不需要继续排序。对右边的子序列(79, 84)进行快速排序，以第一个记录79为基准进行划分，得到以下结果：(79, 84)此时右边的子序列已经有序，不需要继续排序。最终得到的排序结果为：(38, 40, 56, 46, 79, 84)',
            0,1,0,0,0,0,0,0),

            ('下列排序方法中，稳定的排序算法是（ ）',
            'A. 希尔排序',
            'B. 快速排序',
            'C. 归并排序',
            'D. 堆排序',3,
            '归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法',
            0,1,1,0,0,0,0,0);




